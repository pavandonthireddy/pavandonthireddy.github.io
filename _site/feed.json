{
    "version": "https://jsonfeed.org/version/1",
    "title": "Pavan Donthireddy",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "Digital space of notes and thoughts",
    "icon": "http://localhost:4000/apple-touch-iconfavicon.png",
    "favicon": "http://localhost:4000/favicon.png",
    "expired": false,
    
    "author":  {
        "name": "Pavan Donthireddy",
        "url": "https://pavandonthireddy.github.io",
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/2017/04/03/pca-ica-for-fault-detection-single-sensor",
            "title": "PCA-ICA-for-fault-detection-1d-timeseries",
            "summary": "How to apply ICA, PCA for fault detection from single sensor?",
            "content_text": "IdeaPrincipal component analysis (PCA) isa method that transforms multiple data series into uncorrelated data series. Independent component analysis (ICA) is a method that separates multiple data series into independent data series. Both methods have been used in fault detection. However, both require signals from at least two separate sensors. To overcome this requirement and utilize the fault detection capability of ICA and PCA, we propose to use wavelet transform to pre-process the data collected from a single sensor and then use the coefficients of the wavelet transforms at different scales as input to ICA and PCA. Independent components analysis (ICA) requires little prior knowledge about the components to be isolated; however, at least two sensors must be available for signal collection and the number of sensors must be at least equal to the number of sources to be separated and this method cannot be applied directly when there is only one sensor collecting signals.Principal component analysis (PCA) is a multivariate data analysis technique that transforms a set of correlated variables into a set of uncorrelated variables. Each member of the resulting set of uncorrelated variables is called a principal component. We are interested in determining its suitability for fault detection because one of the identified principal components may reveal the signature of a hidden fault. As with ICA, however, this method cannot be applied directly when only a single variable is observed.Wavelet transform may be considered as a series of band pass filters when applied to the datacollected from a single sensor. The results of the transform, which exist in different frequencyregions, say $N$ regions, may be considered as different mixtures of the sources that havegenerated the collected signals.These $N$ groups of data can then be used as input to ICA or PCAfor identification of the hidden sources.ICA and PCAICA is a technique for separating independent sources linearly mixed in signals. Suppose thatthere are $N$ independent sources of vibration, and $N$ sensors at different locations are used torecord vibration signals. The signals recorded by each sensor come from different sources withdifferent mixing ratios. Let $s_{1}(t),s_{2}(t),  \\dots ,s_{N}(t)$ be the signals produced by the $N$ independentsources and $x_{1}(t),x_{2}(t),  \\dots ,x_{N}(t)$ be the observations from the $N$ sensors. The sensors record these signals simultaneously. The task of ICA is to estimate the mixing ratios of the source signals in the collected signals and obtain the independent source signals.To identify the independent components successfully, we need a rule for evaluating theindependency of the identified components. According to the Central Limit Theorem, thedistribution of the sum of a large number of independent random variables tends to a Gaussiandistribution. Since the collected signals are weighted sums of the independent sources, the sourcesto be isolated must have less Gaussianity than the collected signals. Thus, non-Gaussianity can beused for separating independent components. Hyvarinen and Oja proposed to use negentropyto evaluate the non-Gaussianity of the separated components so as to evaluate separationperformance. With this concept, we can seek the separation that provides the least Gaussianness of the separated components. The popular FastICA algorithm proposed by Havarinen and Ojaisoften used to carry out the ICA procedure.PCA is a technique that obtains linear transformations of a group of correlated variables suchthat the transformed variables are uncorrelated. For example, consider two variables, $x_{1}$ and$x_{2}$. For each variable, we have obtained the following $N$ observations:\\(x_{11}, x_{12}, \\dots , x_{1N}; x_{21}, x_{22}, \\dots; x_{2N}\\)where $x_{1i}$ and $x_{2j}$ denote the $i^{th}$ and the $j^{th}$ observations of variables $x_{1}$ and $x_{2}$, respectively. The PCA method seeks two new axes, D1 and D2, that make the projectionsof the collected data ontoD1 have the largest variability and at the same time, the projections of the collected data onto D2have the smallest variability. This way, we have expressed the collected data as their two principalcomponents. Most of the variation in the original data is explained by the first principalcomponent, D1, and the remaining variation in the original data isexplained by the secondprincipal component, D2.ICA renders the separated components independent of one another while PCA renderstheseparated components uncorrelated with one another. PCA separates the components based onlyon the second-order cumulant while ICA separates the components on high-order cumulants.Therefore, ICA can be considered a generalization of PCA.Method of preprocessing to apply ICA or PCA on 1D Time seriesThe available data is a single time series. To apply ICA or PCA for feature extraction, we needto have more than one time series. A method to generate multiple time series from the single available time series is given below.Wavelet transform decomposes a signal series in the time domain into a two-dimensionalfunction in the time-scale (frequency) plane. The wavelet coefficients measure the time-scale (frequency) content in a signal indexed by the scale parameter and the translation parameter. Let$\\varphi(t)$ be the mother wavelet. The wavelet family consists of a series of daughter wavelets that aregenerated by dilation and translation from the mother wavelet $\\varphi(t)$\\[\\varphi_{a, b}(t)=\\sqrt{|a|} \\varphi[(t-b) / a]\\]where $a$ is the scale parameter, $b$ isthe location parameter, and $\\sqrt{  |a|}$isused to guarantee energy preservation. The wavelet transform of signal $x(t)$ isdefined as the inner product of $\\varphi_{a, b}(t)$ and $x(t)$ in the Hilbert space of $L^2$ norm defined as:\\[W(a, b)=\\left\\langle\\varphi_{a, b}(t), x(t)\\right\\rangle=\\int x(t) \\varphi_{a, b}^*(t) \\mathrm{d} t\\]where the symbol * stands for the complex conjugate.Wavelet transform can be thought of as a series of band pass filters. The results of thetransform, which exist in different frequency regions, may be thought of as different mixtures of the independent sources. These different mixtures may be considered to be signals collected atdifferent ‘‘locations’’, or more accurately, through different ‘‘sensors’’ with different frequencyranges. This way, the one-dimensional signal is transformed into multidimensional datathat satisfy the requirements of ICA and PCA. The preprocessing of the one-dimensional data with wavelet transform makes ICA and PCA usable for identification of a hiddensource.Reference :Feature separation using ICA for a one-dimensional time series and its application in fault detection - Ming J. Zuo, Jing Lin, Xianfeng Fan",
            "content_html": "<h3 id=\"idea\">Idea</h3><p align=\"justify\">Principal component analysis (PCA) isa method that transforms multiple data series into uncorrelated data series. Independent component analysis (ICA) is a method that separates multiple data series into independent data series. Both methods have been used in fault detection. However, both require signals from at least two separate sensors. To overcome this requirement and utilize the fault detection capability of ICA and PCA, we propose to use wavelet transform to pre-process the data collected from a single sensor and then use the coefficients of the wavelet transforms at different scales as input to ICA and PCA. </p><p align=\"justify\">Independent components analysis (ICA) requires little prior knowledge about the components to be isolated; however, at least two sensors must be available for signal collection and the number of sensors must be at least equal to the number of sources to be separated and this method cannot be applied directly when there is only one sensor collecting signals.</p><p align=\"justify\">Principal component analysis (PCA) is a multivariate data analysis technique that transforms a set of correlated variables into a set of uncorrelated variables. Each member of the resulting set of uncorrelated variables is called a principal component. We are interested in determining its suitability for fault detection because one of the identified principal components may reveal the signature of a hidden fault. As with ICA, however, this method cannot be applied directly when only a single variable is observed.</p><p>Wavelet transform may be considered as a series of band pass filters when applied to the datacollected from a single sensor. The results of the transform, which exist in different frequencyregions, say $N$ regions, may be considered as different mixtures of the sources that havegenerated the collected signals.These $N$ groups of data can then be used as input to ICA or PCAfor identification of the hidden sources.</p><h3 id=\"ica-and-pca\">ICA and PCA</h3><p>ICA is a technique for separating independent sources linearly mixed in signals. Suppose thatthere are $N$ independent sources of vibration, and $N$ sensors at different locations are used torecord vibration signals. The signals recorded by each sensor come from different sources withdifferent mixing ratios. Let $s_{1}(t),s_{2}(t),  \\dots ,s_{N}(t)$ be the signals produced by the $N$ independentsources and $x_{1}(t),x_{2}(t),  \\dots ,x_{N}(t)$ be the observations from the $N$ sensors. The sensors record these signals simultaneously. The task of ICA is to estimate the mixing ratios of the source signals in the collected signals and obtain the independent source signals.</p><p align=\"justify\">To identify the independent components successfully, we need a rule for evaluating theindependency of the identified components. According to the Central Limit Theorem, thedistribution of the sum of a large number of independent random variables tends to a Gaussiandistribution. Since the collected signals are weighted sums of the independent sources, the sourcesto be isolated must have less Gaussianity than the collected signals. Thus, non-Gaussianity can beused for separating independent components. Hyvarinen and Oja proposed to use negentropyto evaluate the non-Gaussianity of the separated components so as to evaluate separationperformance. With this concept, we can seek the separation that provides the least Gaussianness of the separated components. The popular FastICA algorithm proposed by Havarinen and Ojaisoften used to carry out the ICA procedure.</p><p>PCA is a technique that obtains linear transformations of a group of correlated variables suchthat the transformed variables are uncorrelated. For example, consider two variables, $x_{1}$ and$x_{2}$. For each variable, we have obtained the following $N$ observations:\\(x_{11}, x_{12}, \\dots , x_{1N}; x_{21}, x_{22}, \\dots; x_{2N}\\)where $x_{1i}$ and $x_{2j}$ denote the $i^{th}$ and the $j^{th}$ observations of variables $x_{1}$ and $x_{2}$, respectively. The PCA method seeks two new axes, D1 and D2, that make the projectionsof the collected data ontoD1 have the largest variability and at the same time, the projections of the collected data onto D2have the smallest variability. This way, we have expressed the collected data as their two principalcomponents. Most of the variation in the original data is explained by the first principalcomponent, D1, and the remaining variation in the original data isexplained by the secondprincipal component, D2.</p><p align=\"justify\">ICA renders the separated components independent of one another while PCA renderstheseparated components uncorrelated with one another. PCA separates the components based onlyon the second-order cumulant while ICA separates the components on high-order cumulants.Therefore, ICA can be considered a generalization of PCA.</p><h3 id=\"method-of-preprocessing-to-apply-ica-or-pca-on-1d-time-series\">Method of preprocessing to apply ICA or PCA on 1D Time series</h3><p>The available data is a single time series. To apply ICA or PCA for feature extraction, we needto have more than one time series. A method to generate multiple time series from the single available time series is given below.</p><p>Wavelet transform decomposes a signal series in the time domain into a two-dimensionalfunction in the time-scale (frequency) plane. The wavelet coefficients measure the time-scale (frequency) content in a signal indexed by the scale parameter and the translation parameter. Let$\\varphi(t)$ be the mother wavelet. The wavelet family consists of a series of daughter wavelets that aregenerated by dilation and translation from the mother wavelet $\\varphi(t)$</p>\\[\\varphi_{a, b}(t)=\\sqrt{|a|} \\varphi[(t-b) / a]\\]<p>where $a$ is the scale parameter, $b$ isthe location parameter, and $\\sqrt{  |a|}$isused to guarantee energy preservation. The wavelet transform of signal $x(t)$ isdefined as the inner product of $\\varphi_{a, b}(t)$ and $x(t)$ in the Hilbert space of $L^2$ norm defined as:</p>\\[W(a, b)=\\left\\langle\\varphi_{a, b}(t), x(t)\\right\\rangle=\\int x(t) \\varphi_{a, b}^*(t) \\mathrm{d} t\\]<p>where the symbol * stands for the complex conjugate.</p><p>Wavelet transform can be thought of as a series of band pass filters. The results of thetransform, which exist in different frequency regions, may be thought of as different mixtures of the independent sources. These different mixtures may be considered to be signals collected atdifferent ‘‘locations’’, or more accurately, through different ‘‘sensors’’ with different frequencyranges. This way, the one-dimensional signal is transformed into multidimensional datathat satisfy the requirements of ICA and PCA. The preprocessing of the one-dimensional data with wavelet transform makes ICA and PCA usable for identification of a hiddensource.</p><p><img src=\"/assets/snips/img1.png\" alt=\"Flowchart\" /></p><h3 id=\"reference-\">Reference :</h3><p>Feature separation using ICA for a one-dimensional time series and its application in fault detection - Ming J. Zuo, Jing Lin, Xianfeng Fan</p>",
            "url": "http://localhost:4000/2017/04/03/pca-ica-for-fault-detection-single-sensor",
            
            
            
            "tags": ["ICA","faultdetection","wavelet","PCA","sensors","preprocessing"],
            
            "date_published": "2017-04-03T00:00:00+01:00",
            "date_modified": "2017-04-03T00:00:00+01:00",
            
                "author": "Pavan Donthireddy"
            
        },
    
        {
            "id": "http://localhost:4000/2017/03/21/latex-cheat-sheet",
            "title": "Latex cheatsheet",
            "summary": null,
            "content_text": "DescriptionCheatsheet for LaTex, using Markdown for markup. I use this with atom.ioand :package:markdown-preview-plus to write math stuff. :package:keyboard-localizationis necessary when using an international layout (like [swiss] german).$\\mathrm{abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ23456}$$\\text{abcdeABCDEF ASDFASDF} \\alpha, \\beta, \\gamma$\\[E = mc^2\\]$\\text{This is a text for math} \\Bigg(\\frac{a}{b} \\Bigg)$Further Reference and source: ftp://ftp.ams.org/pub/tex/doc/amsmath/short-math-guide.pdfExample expressions / functions            Input      Rendered                  $a = b + c − d$      $a = b + c − d$              $\\sqrt{?\\frac{\\pi}{2}}$      $\\sqrt{\\frac{\\pi}{2}}$              $y = a x_1^2 + b x_2 + c$      $y = a x_1^2 + b x_2 + c$      Special characters / Symbols###Latin:#####No dot:\\imath $\\rightarrow$ $\\imath$,\\jmath $\\rightarrow$ $\\jmath$#####Hat:\\hat{\\imath}  $\\rightarrow$ $\\hat{\\imath}$,\\hat{\\jmath}  $\\rightarrow$ $\\hat{\\jmath}$###Greek Letters:#####Capital:LaTex      |   | LaTex    |   |———-:|–:|———:|–:|\\Gamma   | Γ | \\Delta | ∆ |\\Lambda  | Λ | \\Phi   | Φ |\\Pi      | Π | \\Psi   | Ψ |\\Sigma   | Σ | \\Theta | Θ |\\Upsilon | Υ | \\Xi    | Ξ |\\Omega   | Ω |          |   |#####Lowercase:LaTex      |   | LaTex     |   |———-:|–:|———-:|–:|\\alpha   | α | \\nu     | ν |\\beta    | β | \\kappa  | κ |\\gamma   | γ | \\lambda | λ |\\delta   | δ |  \\mu    | µ |  \\epsilon | ϵ | \\zeta   | ζ |\\eta     | η | \\theta  | θ |\\iota    | ι | \\xi     | ξ |\\pi      | π | \\rho    | ρ |\\sigma   | σ | \\tau    | τ |\\upsilon | υ | \\phi    | φ |\\chi     | χ | \\psi    | ψ |\\omega   | ω |           |   |#####Other:LaTex       |   | LaTex       |   |———–:|—|————:|–:|\\digamma  | ϝ | varepsilon| ε       |\\varkappa | ϰ | \\varphi   | ϕ       |\\varpi    | ϖ | \\varrho   | ϱ       |\\varsigma | ς | \\vartheta | ϑ       |\\eth      | ð | \\hbar     | $\\hbar$ |###Other:####Other SymbolsLaTex         |   | LaTex            |   |————-:|—|—————–:|–:|\\partial    | ∂ | \\infty         | ∞ |\\wedge      | ∧ | \\vee           | ∨ |\\neg \\not | ¬ |                  |   |\\bot        | ⊥ | \\top           | ⊤ |\\nabla      | ∇ | \\varnothing    | ∅ |\\angle      | ∠ | \\measuredangle | ∡ |\\surd       | √ | \\forall        | ∀ |\\exists     | ∃ | \\nexists       | ∄ |####Relational SymbolsLaTex             |   | LaTex              |          |—————–:|—|——————-:|———:|\\hookrightarrow | ↪      | \\Rightarrow     | ⇒         |\\rightarrow     | →      | \\Leftrightarrow | ⇔         |\\nrightarrow    | ↛      | \\mapsto         | $\\mapsto$ |\\geq            | ≥      | \\leq            | ≤         |\\equiv          | ≡      | \\sim            | ∼         |\\gg             | ≫      | \\ll            | ≪          |\\subset          | ⊂     | \\subseteq     | ⊆           |\\in             | ∈      | \\notin         | ∉          |\\mid            | $\\mid$ | \\propto        | ∝          |\\perp            | ⊥     | ` \\parallel     | ∥          |\\vartriangle`     | $\\vartriangle$####Binary operatorsLaTex        |   | LaTex  |   |————:|—|——-:|–:|\\wedge     | ∧ | \\vee | ∨ |\\neg\\not | ¬ |        |   |####Cumulative operatorsLaTex     |           | LaTex       |             |———:|———–|————:|————:|\\int    | ∫         | \\iint     | $\\iint$     |\\iiint  | $\\iiint$  | \\idotsint | $\\idotsint$ |\\prod   | $\\prod$   | \\sum      | $\\sum$      |\\bigcup | $\\bigcup$ | \\bigcap   | $\\bigcap$   |####Named operators$\\arccos$,$\\arcsin$,$\\arctan$,$\\arg$,$\\cos$,$\\cosh$,$\\cot$,$\\coth$,$\\deg$,$\\det$,$\\dim$,$\\exp$,$\\gcd$,$\\hom$,$\\inf$,$\\injlim$,$\\lg$,$\\lim$,$\\liminf$,$\\limsup$,$\\ln$,$\\log$,$\\max$,$\\min$,$\\Pr$,$\\projlim$,$\\sec$,$\\sin$,$\\sinh$,$\\sup$",
            "content_html": "<h1 id=\"description\">Description</h1><p>Cheatsheet for LaTex, using Markdown for markup. I use this with <a href=\"https://atom.io/\">atom.io</a>and :package:<code>markdown-preview-plus</code> to write math stuff. :package:<code>keyboard-localization</code>is necessary when using an international layout (like [swiss] german).</p><p>$\\mathrm{abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ23456}$</p><p>$\\text{abcdeABCDEF ASDFASDF} \\alpha, \\beta, \\gamma$</p>\\[E = mc^2\\]<p>$\\text{This is a text for math} \\Bigg(\\frac{a}{b} \\Bigg)$</p><p>Further Reference and source: ftp://ftp.ams.org/pub/tex/doc/amsmath/short-math-guide.pdf</p><h1 id=\"example-expressions--functions\">Example expressions / functions</h1><table>  <thead>    <tr>      <th style=\"text-align: right\">Input</th>      <th style=\"text-align: right\">Rendered</th>    </tr>  </thead>  <tbody>    <tr>      <td style=\"text-align: right\"><code>$a = b + c − d$</code></td>      <td style=\"text-align: right\">$a = b + c − d$</td>    </tr>    <tr>      <td style=\"text-align: right\"><code>$\\sqrt{?\\frac{\\pi}{2}}$</code></td>      <td style=\"text-align: right\">$\\sqrt{\\frac{\\pi}{2}}$</td>    </tr>    <tr>      <td style=\"text-align: right\"><code>$y = a x_1^2 + b x_2 + c$</code></td>      <td style=\"text-align: right\">$y = a x_1^2 + b x_2 + c$</td>    </tr>  </tbody></table><h1 id=\"special-characters--symbols\">Special characters / Symbols</h1><p>###Latin:#####No dot:<br /><code>\\imath</code> $\\rightarrow$ $\\imath$,<code>\\jmath</code> $\\rightarrow$ $\\jmath$</p><p>#####Hat:<br /><code>\\hat{\\imath}</code>  $\\rightarrow$ $\\hat{\\imath}$,<code>\\hat{\\jmath}</code>  $\\rightarrow$ $\\hat{\\jmath}$</p><p>###Greek Letters:#####Capital:LaTex      |   | LaTex    |   |———-:|–:|———:|–:|<code>\\Gamma</code>   | Γ | <code>\\Delta</code> | ∆ |<code>\\Lambda</code>  | Λ | <code>\\Phi</code>   | Φ |<code>\\Pi</code>      | Π | <code>\\Psi</code>   | Ψ |<code>\\Sigma</code>   | Σ | <code>\\Theta</code> | Θ |<code>\\Upsilon</code> | Υ | <code>\\Xi</code>    | Ξ |<code>\\Omega</code>   | Ω |          |   |</p><p>#####Lowercase:LaTex      |   | LaTex     |   |———-:|–:|———-:|–:|<code>\\alpha</code>   | α | <code>\\nu</code>     | ν |<code>\\beta</code>    | β | <code>\\kappa</code>  | κ |<code>\\gamma</code>   | γ | <code>\\lambda</code> | λ |<code>\\delta</code>   | δ |  <code>\\mu</code>    | µ |  <br /><code>\\epsilon</code> | ϵ | <code>\\zeta</code>   | ζ |<code>\\eta</code>     | η | <code>\\theta</code>  | θ |<code>\\iota</code>    | ι | <code>\\xi</code>     | ξ |<code>\\pi</code>      | π | <code>\\rho</code>    | ρ |<code>\\sigma</code>   | σ | <code>\\tau</code>    | τ |<code>\\upsilon</code> | υ | <code>\\phi</code>    | φ |<code>\\chi</code>     | χ | <code>\\psi</code>    | ψ |<code>\\omega</code>   | ω |           |   |</p><p>#####Other:LaTex       |   | LaTex       |   |———–:|—|————:|–:|<code>\\digamma</code>  | ϝ | <code>varepsilon</code>| ε       |<code>\\varkappa</code> | ϰ | <code>\\varphi</code>   | ϕ       |<code>\\varpi</code>    | ϖ | <code>\\varrho</code>   | ϱ       |<code>\\varsigma</code> | ς | <code>\\vartheta</code> | ϑ       |<code>\\eth</code>      | ð | <code>\\hbar</code>     | $\\hbar$ |</p><p>###Other:####Other SymbolsLaTex         |   | LaTex            |   |————-:|—|—————–:|–:|<code>\\partial</code>    | ∂ | <code>\\infty</code>         | ∞ |<code>\\wedge</code>      | ∧ | <code>\\vee</code>           | ∨ |<code>\\neg</code> <code>\\not</code> | ¬ |                  |   |<code>\\bot</code>        | ⊥ | <code>\\top</code>           | ⊤ |<code>\\nabla</code>      | ∇ | <code>\\varnothing</code>    | ∅ |<code>\\angle</code>      | ∠ | <code>\\measuredangle</code> | ∡ |<code>\\surd</code>       | √ | <code>\\forall</code>        | ∀ |<code>\\exists</code>     | ∃ | <code>\\nexists</code>       | ∄ |</p><p>####Relational SymbolsLaTex             |   | LaTex              |          |—————–:|—|——————-:|———:|<code>\\hookrightarrow</code> | ↪      | <code>\\Rightarrow</code>     | ⇒         |<code>\\rightarrow</code>     | →      | <code>\\Leftrightarrow</code> | ⇔         |<code>\\nrightarrow</code>    | ↛      | <code>\\mapsto</code>         | $\\mapsto$ |<code>\\geq</code>            | ≥      | <code>\\leq</code>            | ≤         |<code>\\equiv</code>          | ≡      | <code>\\sim</code>            | ∼         |<code>\\gg</code>             | ≫      | <code>\\ll</code>            | ≪          |<code>\\subset</code>          | ⊂     | <code>\\subseteq</code>     | ⊆           |<code>\\in</code>             | ∈      | <code>\\notin</code>         | ∉          |<code>\\mid</code>            | $\\mid$ | <code>\\propto</code>        | ∝          |<code>\\perp</code>            | ⊥     | ` \\parallel<code>     | ∥          |</code>\\vartriangle`     | $\\vartriangle$</p><p>####Binary operatorsLaTex        |   | LaTex  |   |————:|—|——-:|–:|<code>\\wedge</code>     | ∧ | <code>\\vee</code> | ∨ |<code>\\neg</code><code>\\not</code> | ¬ |        |   |</p><p>####Cumulative operatorsLaTex     |           | LaTex       |             |———:|———–|————:|————:|<code>\\int</code>    | ∫         | <code>\\iint</code>     | $\\iint$     |<code>\\iiint</code>  | $\\iiint$  | <code>\\idotsint</code> | $\\idotsint$ |<code>\\prod</code>   | $\\prod$   | <code>\\sum</code>      | $\\sum$      |<code>\\bigcup</code> | $\\bigcup$ | <code>\\bigcap</code>   | $\\bigcap$   |</p><p>####Named operators$\\arccos$,$\\arcsin$,$\\arctan$,$\\arg$,$\\cos$,$\\cosh$,$\\cot$,$\\coth$,$\\deg$,$\\det$,$\\dim$,$\\exp$,$\\gcd$,$\\hom$,$\\inf$,$\\injlim$,$\\lg$,$\\lim$,$\\liminf$,$\\limsup$,$\\ln$,$\\log$,$\\max$,$\\min$,$\\Pr$,$\\projlim$,$\\sec$,$\\sin$,$\\sinh$,$\\sup$</p>",
            "url": "http://localhost:4000/2017/03/21/latex-cheat-sheet",
            
            
            
            "tags": ["latex","css"],
            
            "date_published": "2017-03-21T00:00:00+00:00",
            "date_modified": "2017-03-21T00:00:00+00:00",
            
                "author": "Bart SimpsonNelson Mandela Muntz"
            
        }
    
    ]
}