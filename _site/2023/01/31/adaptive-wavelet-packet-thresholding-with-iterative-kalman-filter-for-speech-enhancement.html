<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Adaptive Wavelet Packet thresholding with iterative kalman filter" /><meta property="og:locale" content="en_US" /><meta name="description" content="Adaptive Wavelet Packet thresholding with iterative kalman filter" /><meta property="og:description" content="Adaptive Wavelet Packet thresholding with iterative kalman filter" /><link rel="canonical" href="http://localhost:4000/2023/01/31/adaptive-wavelet-packet-thresholding-with-iterative-kalman-filter-for-speech-enhancement" /><meta property="og:url" content="http://localhost:4000/2023/01/31/adaptive-wavelet-packet-thresholding-with-iterative-kalman-filter-for-speech-enhancement" /><meta property="og:site_name" content="Pavan Donthireddy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-31T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Adaptive Wavelet Packet thresholding with iterative kalman filter" /><meta name="twitter:site" content="@" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-31T00:00:00+00:00","datePublished":"2023-01-31T00:00:00+00:00","description":"Adaptive Wavelet Packet thresholding with iterative kalman filter","headline":"Adaptive Wavelet Packet thresholding with iterative kalman filter","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/01/31/adaptive-wavelet-packet-thresholding-with-iterative-kalman-filter-for-speech-enhancement"},"url":"http://localhost:4000/2023/01/31/adaptive-wavelet-packet-thresholding-with-iterative-kalman-filter-for-speech-enhancement"}</script><title> Adaptive Wavelet Packet thresholding with iterative kalman filter - Pavan Donthireddy</title><meta charset="UTF-8"><link rel="canonical" href="http://localhost:4000/2023/01/31/adaptive-wavelet-packet-thresholding-with-iterative-kalman-filter-for-speech-enhancement" /><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Abstract"><meta property="og:site_name" content="Pavan Donthireddy"><meta property="og:description" content="Abstract"/><meta property="og:title" content="Adaptive Wavelet Packet thresholding with iterative kalman filter"><meta property="og:type" content="article"><meta property="article:published_time" content="2023-01-31T00:00:00+00:00"><meta property="article:author" content="http://localhost:4000/"><meta property="og:url" content="http://localhost:4000/2023/01/31/adaptive-wavelet-packet-thresholding-with-iterative-kalman-filter-for-speech-enhancement" /><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Pavan Donthireddy" href="/atom.xml"><link rel="alternate" type="application/json" title="Pavan Donthireddy" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX","input/MathML","output/SVG", "output/CommonHTML"], extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "CHTML-preview.js"], TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }, tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, messageStyle: "none", "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }, TeX: { equationNumbers: { autoNumber: "AMS" }, extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js"], TagSide: "left", Macros: { field: ['\\mathbb{#1}', 1], C: ['\\field{C}'], E: ['\\field{E}'], F: ['\\field{F}'], N: ['\\field{N}'], P: ['\\field{P}'], Q: ['\\field{Q}'], R: ['\\field{R}'], Z: ['\\field{Z}'], ha : ['\\hat{#1}',1], Re: ['\\mathop{\\mathrm{Re}}'], Im: ['\\mathop{\\mathrm{Im}}'], Res: ['\\mathop{\\mathrm{Res}}'], } } }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.post-archive{font-size:15px;line-height:2;padding-bottom:.8em}.post-archive .date{padding-right:.7em}.pagination{width:100%;padding:0 20px;text-align:center}.pagination ul{list-style:none}.pagination ul li{display:inline;margin:0 5px}.pagination ul li a{color:#000;text-decoration:none}.pagination ul li a:hover{color:gray;text-decoration:underline}.pagination ul li.current-page a{background:#ddd;color:#fff}.post-link{position:relative;display:inline-block}.post-excerpt{display:none;position:absolute;z-index:1;top:100%;left:0;width:100%;padding:10px;background-color:#fff;box-shadow:0 2px 5px rgba(0,0,0,.1)}.post-link:hover .post-excerpt{display:block}.img-padding{width:200px;height:200px;padding:20px 20px 20px 20px}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">Pavan Donthireddy</h1>--><nav role="navigation"><ul><li><a href="/" >Notes</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search" >Search</a></li><li><a href="/about" >About</a></li></ul></nav></header><link rel="stylesheet" href="/assets/js/prism.css"><link rel="stylesheet" href="/assets/js/prism-line-numbers.css"><section class="post"> <script src="/assets/js/prism.js"></script> <script src="/assets/js/prism-line-numbers.js"></script><h1 style="text-align: center;">Adaptive Wavelet Packet thresholding with iterative kalman filter</h1><div style="text-align: center;"><span class="meta"><time datetime="2023-01-31T00:00:00+00:00">January 31, 2023</time> </span></div><div style="text-align: center;"><span class="meta"> <a href="/tag/wavelet">wavelet</a>, <a href="/tag/kalman">kalman</a>, <a href="/tag/preprocessing">preprocessing</a>, <a href="/tag/wavelet_thresholding">wavelet_thresholding</a></span></div><h2 id="abstract">Abstract</h2><p align="justify">In this paper, we propose an adaptive wavelet packet (WP) thresholding method with iterative Kalman filter (IKF) for speech enhancement. The WP transform is first applied to the noise corrupted speech on a frame-by-frame basis, which decomposes each frame into a number of subbands. For each subband, a voice activity detector (VAD) is designed to detect the voiced/unvoiced parts of the speech. Based on the VAD result, an adaptive thresholding scheme is then utilized to each subband speech to obtain the pre-enhanced speech. To achieve a further level of enhancement, an IKF is next applied to the pre-enhanced speech. The proposed method is evaluated under various noise conditions. Experimental results are provided to demonstrate the effectiveness of the proposed method as compared to some previous works in terms of segmental SNR and perceptual evaluation of speech quality (PESQ) as two well-known performance indexes</p><h2 id="introduction">Introduction</h2><p align="justify">Wavelet Packet (WP), as a well-known powerful method, is used in several signal processing applications including speech enhancement. Based on an adaptive thresholding in wavelet packets, a speech enhancement approach is proposed in [3], where a subband thresholding is applied to detect the voice/noise frames. The criterion used in [3] to determine voiced and noise frames is to compare the frame energy with a constant threshold. Namely, a voiced frame is detected if the frame energy exceeds the constant threshold. Otherwise,the frame is decided as noise. In practice, however, such an energy-based decision making would fail to identify all voice or noise frames. To increase the detection accuracy, other frame characteristics need to be considered.</p><p align="justify">The authors in [4] proposed an iterative Kalman filter (IKF) approach for speech enhancement, where the linear prediction coefficients (LPCs) and the noise variance are estimated directly from the noisy speech, which decreases the accuracy of IKF approach to a certain degree. In [5], another IKF-based approach is proposed along with a subband processing, where the noisy speech is decomposed into a number of subbands followed by Kalman Filtering (KF) on each subband. The method, however, demands a large amount of computational resource for the implementation of KF at all the subbands. More recently, a subband IKF method with partial reconstruction is proposed in [6], where the noisy speech is first decomposed into a set of subbands, and then a partial reconstruction scheme is used to reconstruct the subbands into high-frequency and low-frequency subband speeches. In this context, the IKF is employed only in the high-frequency subband. Since the low-frequency subband is not filtered by the IKF, this method offers limited enhancement performance for noisy speeches which contain non-negligible noises in lowfrequency region.</p><p align="justify">In order to address the aforementioned limitations, in this paper we propose an improved thresholding scheme with the IKF for speech enhancement on a frame-by-frame basis. The noisy speech is first decomposed into a number of subbands with the WP. The VAD is then applied to each subband frame to determine whether the frame is voice or noise. In contrast to most existing works where only a single parameter is employed for voice/noise frame detection, our method makes use of two measurements in the VAD stage. i) frame energy and ii) spectral flatness. A VAD based adaptive thresholding scheme is then proposed for speech enhancement in accordance with each subband frame activity. Finally, an IKF is used for further noise reduction, which is followed by reconstruction of the full-band speech from the enhanced subband speeches.</p><h2 id="iterative-kalman-filter">Iterative Kalman Filter</h2><p>Here, the pre-enhanced full-band speech signal $\hat{y}(k)$ is further processed by an IKF as modelled below \(\begin{aligned} &amp; \hat{y}(k)=\boldsymbol{H} \boldsymbol{x}(k)+w(k), \\ &amp; \boldsymbol{x}(k)=\boldsymbol{F} \boldsymbol{x}(k-1)+\boldsymbol{G} u(k), \end{aligned}\) with $\boldsymbol{H}=\boldsymbol{G}^T=[1, \ldots, 1] \in \mathbb{R}^{1 \times p}, \boldsymbol{x}(k)=[s(k-p+1), \ldots, s(k)]$. The term $\boldsymbol{F}$ denotes the $p \times p$ state transition matrix represented as LPCs estimation based on Modified Yule-Walker equations $[10]$ \(\boldsymbol{F}=\left[\begin{array}{ccccc} -a_1 &amp; -a_2 &amp; \cdots &amp; -a_{p-1} &amp; -a_p \\ 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\ 0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0 \end{array}\right]\) The number of iterations is usually set to 2 or 3 . The operation principle of the IKF includes a prediction step and a measurement update step. In the prediction step, the IKF predicts the state vector and parameter covariance by using the previous samples of the state-space model. The estimate of clean speech $\hat{x}(k)$ and the posteriori estimation error covariance $P(k \mid k)$ are predicted from time step $(k-1)$ to step $k$ (the status are $\hat{x}(k \mid k-1) / P(k \mid k-1)$ ), \(\begin{aligned} \hat{\boldsymbol{x}}(k \mid k-1) &amp; =\boldsymbol{F} \hat{\boldsymbol{x}}(k-1 \mid k-1), \\ P(k \mid k-1) &amp; =\boldsymbol{F} P(k-1 \mid k-1) \boldsymbol{F}^T+G \sigma_u{ }^2 G^T . \end{aligned}\) In the measurement update step, the Kalman Gain and state vectors are updated by \(\begin{aligned} \boldsymbol{K}(k) &amp; =P(k \mid k-1) \boldsymbol{H}^T\left(\boldsymbol{H} P_{(k \mid k-1)} \boldsymbol{H}^T+\sigma_w{ }^2\right)^{-1}, \\ \hat{\boldsymbol{x}}(k \mid k) &amp; =\hat{\boldsymbol{x}}(k \mid k-1)+\boldsymbol{K}(k)(y(k)-\boldsymbol{H} \hat{\boldsymbol{x}}(k \mid k-1)), \\ P(k \mid k) &amp; =(\boldsymbol{I}-\boldsymbol{K}(k) \boldsymbol{H}) P(k \mid k-1), \end{aligned}\) where $\boldsymbol{I}$ denotes the identity matrix.</p><h2 id="comparison">Comparison</h2><p align="justify">Three existing methods namely, adaptive threshold (AT) [9], iterative Kalman filter (IKF) [4] and subband iterative Kalman filter (S-IKF) [6], are compared with the proposed adaptive threshold iterative Kalman filter (AT-IKF) method. Standard objective metrics, i.e., segmental SNR and PESQ, are applied for performance evaluations. From Fig. 4, it is observed that in non-stationary noise environment the proposed method achieves the same performance as compared with the IKF and S-IKF methods in terms of segmental SNR. However, the experimental results shown in Fig. 5 demonstrate a performance improvement in terms of PESQ. Moreover, as shown in Fig. 6 and Fig. 7, the proposed scheme outperforms the other methods both in terms of segmental SNR and PESQ.</p><hr> <side style="font-size: 0.9em"><h3 style="margin-bottom: 1em">Notes mentioning this note</h3><div style="font-size: 0.9em"><p> There are no notes linking to this note.</p></div></side> <a href="" class="post-link"><h2></h2><p class="post-excerpt"></p></a> <script src="https://giscus.app/client.js" data-repo="pavandonthireddy/pavandonthireddy.github.io" data-repo-id="[ENTER REPO ID HERE]" data-category="[ENTER CATEGORY NAME HERE]" data-category-id="[ENTER CATEGORY ID HERE]" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="light_high_contrast" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></section></main></body></html>
