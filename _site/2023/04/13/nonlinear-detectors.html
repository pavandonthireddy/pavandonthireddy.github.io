<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Non-Linear Detectors like SC Detector and its Variants" /><meta name="author" content="Pavan Donthireddy" /><meta property="og:locale" content="en_US" /><meta name="description" content="This article explains Non-Linear Detectors like SC Detector and its Variants with Statistics and Equations in LaTeX. It also includes Python Implementation for all Variants." /><meta property="og:description" content="This article explains Non-Linear Detectors like SC Detector and its Variants with Statistics and Equations in LaTeX. It also includes Python Implementation for all Variants." /><link rel="canonical" href="http://localhost:4000/2023/04/13/nonlinear-detectors" /><meta property="og:url" content="http://localhost:4000/2023/04/13/nonlinear-detectors" /><meta property="og:site_name" content="Pavan Donthireddy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-13T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Non-Linear Detectors like SC Detector and its Variants" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Pavan Donthireddy" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pavan Donthireddy"},"dateModified":"2023-04-13T00:00:00+01:00","datePublished":"2023-04-13T00:00:00+01:00","description":"This article explains Non-Linear Detectors like SC Detector and its Variants with Statistics and Equations in LaTeX. It also includes Python Implementation for all Variants.","headline":"Non-Linear Detectors like SC Detector and its Variants","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/04/13/nonlinear-detectors"},"url":"http://localhost:4000/2023/04/13/nonlinear-detectors"}</script><title> Non-Linear Detectors like SC Detector and its Variants - Pavan Donthireddy</title><meta charset="UTF-8"><link rel="canonical" href="http://localhost:4000/2023/04/13/nonlinear-detectors" /><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Introduction"><meta property="og:site_name" content="Pavan Donthireddy"><meta property="og:description" content="Introduction"/><meta property="og:title" content="Non-Linear Detectors like SC Detector and its Variants"><meta property="og:type" content="article"><meta property="article:published_time" content="2023-04-13T00:00:00+01:00"><meta property="article:author" content="http://localhost:4000/"><meta property="og:url" content="http://localhost:4000/2023/04/13/nonlinear-detectors" /><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Pavan Donthireddy" href="/atom.xml"><link rel="alternate" type="application/json" title="Pavan Donthireddy" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX","input/MathML","output/SVG", "output/CommonHTML"], extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "CHTML-preview.js"], TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }, tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, messageStyle: "none", "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }, TeX: { equationNumbers: { autoNumber: "AMS" }, extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js"], TagSide: "left", Macros: { field: ['\\mathbb{#1}', 1], C: ['\\field{C}'], E: ['\\field{E}'], F: ['\\field{F}'], N: ['\\field{N}'], P: ['\\field{P}'], Q: ['\\field{Q}'], R: ['\\field{R}'], Z: ['\\field{Z}'], ha : ['\\hat{#1}',1], Re: ['\\mathop{\\mathrm{Re}}'], Im: ['\\mathop{\\mathrm{Im}}'], Res: ['\\mathop{\\mathrm{Res}}'], } } }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.post-archive{font-size:15px;line-height:2;padding-bottom:.8em}.post-archive .date{padding-right:.7em}.pagination{width:100%;padding:0 20px;text-align:center}.pagination ul{list-style:none}.pagination ul li{display:inline;margin:0 5px}.pagination ul li a{color:#000;text-decoration:none}.pagination ul li a:hover{color:gray;text-decoration:underline}.pagination ul li.current-page a{background:#ddd;color:#fff}.post-link{position:relative;display:inline-block}.post-excerpt{display:none;position:absolute;z-index:1;top:100%;left:0;width:100%;padding:10px;background-color:#fff;box-shadow:0 2px 5px rgba(0,0,0,.1)}.post-link:hover .post-excerpt{display:block}.img-padding{width:200px;height:200px;padding:20px 20px 20px 20px}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">Pavan Donthireddy</h1>--><nav role="navigation"><ul><li><a href="/" >Notes</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search" >Search</a></li><li><a href="/about" >About</a></li></ul></nav></header><section class="post"><h1 style="text-align: center;">Non-Linear Detectors like SC Detector and its Variants</h1><div style="text-align: center;"><span class="meta"><time datetime="2023-04-13T00:00:00+01:00">April 13, 2023</time> </span></div><div style="text-align: center;"><span class="meta"> <a href="/tag/signal_detection">signal_detection</a></span></div><h2 id="introduction">Introduction</h2><p>Non-linear detectors play an important role in signal processing applications. They are used in various applications, such as communications, radar, and medical imaging. The non-linear detectors are classified into two categories, namely parametric and non-parametric detectors. The parametric detectors require knowledge of the signal statistics, whereas the non-parametric detectors do not require any statistical information about the signals.</p><p>One popular non-linear detector is the Sequentially Cyclic (SC) detector (also known as the Sawtooth detector), which is widely used in communication systems. In this article, we will discuss the SC detector in detail, along with its variants and their statistics and equations in LaTeX. Additionally, we will include Python implementation for all variants.</p><h2 id="sc-detector">SC Detector</h2><p>The Sequentially Cyclic (SC) detector is a non-linear detector used for detecting the presence of a signal of known frequency in noise. It is a simple but effective detector that is widely used in communication systems. The SC detector works by multiplying the input signal with a reference signal, which is a sawtooth waveform with the same frequency as the input signal. The sawtooth waveform is generated by a voltage-controlled oscillator (VCO), as shown in Figure 1.</p><p><img src="https://i.imgur.com/dsw5V7O.png" alt="SC Detector Block Diagram" /></p><p><em>Figure 1: Block Diagram of SC Detector</em></p><p>The output of the multiplier is a sum of harmonics of the input signal frequency, which is filtered by a bandpass filter (BPF) centered at the input frequency. The output of the BPF is then rectified and low-pass filtered (LPF) to obtain the Envelope of the input signal, as shown in Figure 2.</p><p><img src="https://i.imgur.com/2ZQURWd.png" alt="SC Detector Output Waveforms" /></p><p><em>Figure 2: SC Detector Output Waveforms</em></p><p>The envelope output is compared to a threshold, which is set according to the noise level. If the envelope output exceeds the threshold, it is considered as a signal present.</p><h2 id="sc-detector-variants">SC Detector Variants</h2><p>There are several variants of the SC detector, which are listed below:</p><h3 id="quadrature-sc-detector-qscd">Quadrature SC Detector (QSCD)</h3><p>The Quadrature SC Detector (QSCD) is a variant of the SC detector that uses two reference signals, which are in-phase and quadrature-phase (I/Q) with the input signal. The reference signals are generated by two voltage-controlled oscillators (VCOs), as shown in Figure 3.</p><p><img src="https://i.imgur.com/65Fcgs0.png" alt="QSCD Block Diagram" /></p><p><em>Figure 3: Block Diagram of QSCD</em></p><p>The output of the QSCD is obtained by adding the envelope outputs of the I and Q channels. The threshold for the QSCD is set according to the noise level.</p><h3 id="multi-stage-sc-detector-msscd">Multi-Stage SC Detector (MSSCD)</h3><p>The Multi-Stage SC Detector (MSSCD) is a variant of the SC detector that uses multiple stages of bandpass filtering to suppress noise. The MSSCD works by bandpass filtering the input signal at multiple stages, as shown in Figure 4.</p><p><img src="https://i.imgur.com/gtDfHtI.png" alt="MSSCD Block Diagram" /></p><p><em>Figure 4: Block Diagram of MSSCD</em></p><p>The output of each stage is rectified and low-pass filtered, and then added to obtain the final output. The threshold for the MSSCD is set according to the noise level.</p><h3 id="multi-band-sc-detector-mbscd">Multi-Band SC Detector (MBSCD)</h3><p>The Multi-Band SC Detector (MBSCD) is a variant of the SC detector that uses multiple bandpass filters to separate the input signal into multiple frequency bands. The MBSCD works by splitting the input signal into multiple frequency bands using bandpass filters, as shown in Figure 5.</p><p><img src="https://i.imgur.com/Yc3W6Oe.png" alt="MBSCD Block Diagram" /></p><p><em>Figure 5: Block Diagram of MBSCD</em></p><p>The output of each bandpass filter is rectified and low-pass filtered, and then added to obtain the final output. The threshold for the MBSCD is set according to the noise level.</p><h2 id="statistics-and-equations">Statistics and Equations</h2><p>In this section, we will discuss the statistics and equations for the SC detector and its variants.</p><h3 id="sc-detector-1">SC Detector</h3><p>The output of the SC detector is given by:</p>\[S_{out} = \sqrt{2}A_I\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}A_Q\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + N(t)\]<p>where $J_n(B)$ is the Bessel function of the first kind and order $n$, $B$ is the modulation index, $A_I$ and $A_Q$ are the amplitudes of the I and Q channels, $\omega_0$ is the frequency of the input signal, $t$ is time, and $N(t)$ is the Gaussian noise.</p><p>The envelope output of the SC detector is given by:</p>\[E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + \sqrt{(N(t))^2}\]<p>where $\phi_n$ and $\psi_n$ are the phases of the I and Q channels, respectively.</p><p>The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the SC detector are given by:</p>\[P_D = Q(\frac{\gamma - d^2}{2\sigma})\] \[P_{FA} = Q(\frac{\gamma}{2\sigma})\]<p>where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.</p><h3 id="qscd">QSCD</h3><p>The output of the QSCD is given by:</p>\[S_{out} = \sqrt{2}A_I\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}A_Q\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + N(t)\]<p>The envelope output of the QSCD is given by:</p>\[E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + \sqrt{(N(t))^2}\]<p>The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the QSCD are given by:</p>\[P_D = Q(\frac{\gamma - d^2}{2\sigma})\] \[P_{FA} = Q(\frac{\gamma}{2\sigma})\]<p>where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.</p><h3 id="msscd">MSSCD</h3><p>The output of the MSSCD is given by:</p>\[S_{out} = \sum_{i=1}^{N} \sqrt{2}A_i\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + N(t)\]<p>The envelope output of the MSSCD is given by:</p>\[E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{i=1}^{N}\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + \sqrt{(N(t))^2}\]<p>The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the MSSCD are given by:</p>\[P_D = Q(\frac{\gamma - d^2}{2\sigma})\] \[P_{FA} = Q(\frac{\gamma}{2\sigma})\]<p>where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.</p><h3 id="mbscd">MBSCD</h3><p>The output of the MBSCD is given by:</p>\[S_{out} = \sum_{i=1}^{N} \sqrt{2}A_i\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + N(t)\]<p>The envelope output of the MBSCD is given by:</p>\[E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{i=1}^{N}\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + \sqrt{(N(t))^2}\]<p>The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the MBSCD are given by:</p>\[P_D = Q(\frac{\gamma - d^2}{2\sigma})\] \[P_{FA} = Q(\frac{\gamma}{2\sigma})\]<p>where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.</p><h2 id="python-implementation">Python Implementation</h2><p>In this section, we will provide Python implementation for the SC detector and its variants.</p><pre><code class="language-python">import numpy as np
import scipy.special as sp

def sc_detector(x, fs, fc, bw, th):
    # Generate sawtooth waveform
    N = len(x)
    t = np.linspace(0, N/fs, N, endpoint=False)
    sawtooth = sp.sawtooth(2 * np.pi * fc * t)
    # Multiply input signal with sawtooth waveform
    s_out = x * sawtooth
    # Apply bandpass filter
    b, a = signal.butter(4, [fc-bw/2, fc+bw/2], btype='band')
    s_out = signal.filtfilt(b, a, s_out)
    # Rectify and low-pass filter
    s_out = np.abs(s_out)
    b, a = signal.butter(4, 2 * fc / fs, btype='low')
    s_out = signal.filtfilt(b, a, s_out)
    # Thresholding
    if np.max(s_out) &gt; th:
        return True
    else:
        return False

def qsc_detector(x, fs, fc, bw, th):
    # Generate I and Q reference signals
    N = len(x)
    t = np.linspace(0, N/fs, N, endpoint=False)
    i_ref = np.cos(2 * np.pi * fc * t)
    q_ref = np.sin(2 * np.pi * fc * t)
    # Multiply input signal with I and Q reference signals
    i_out = x * i_ref
    q_out = x * q_ref
    # Apply bandpass filter
    b, a = signal.butter(4, [fc-bw/2, fc+bw/2], btype='band')
    i_out = signal.filtfilt(b, a, i_out)
    q_out = signal.filtfilt(b, a, q_out)
    # Rectify and low-pass filter
    i_out = np.abs(i_out)
    q_out = np.abs(q_out)
    b, a = signal.butter(4, 2 * fc / fs, btype='low')
    i_out = signal.filtfilt(b, a, i_out)
    q_out = signal.filtfilt(b, a, q_out)
    # Sum the envelope outputs of I and Q channels
    s_out = i_out + q_out
    # Thresholding
    if np.max(s_out) &gt; th:
        return True
    else:
        return False

def mss_detector(x, fs, fc, bw, th, N):
    # Generate sawtooth waveform for each stage
    t = np.linspace(0, len(x)/fs, len(x), endpoint=False)
    stages = []
    for i in range(N):
        stage = sp.sawtooth(2 * np.pi * fc[i] * t)
        stages.append(stage)
    # Apply bandpass filter for each stage
    s_out = np.zeros(len(x))
    for i in range(N):
        b, a = signal.butter(4, [fc[i]-bw[i]/2, fc[i]+bw[i]/2], btype='band')
        s_out_stage = signal.filtfilt(b, a, x * stages[i])
        # Rectify and low-pass filter
        s_out_stage = np.abs(s_out_stage)
        b, a = signal.butter(4, 2 * fc[i] / fs, btype='low')
        s_out_stage = signal.filtfilt(b, a, s_out_stage)
        # Add the envelope output of the current stage to the final output
        s_out += s_out_stage
    # Thresholding
    if np.max(s_out) &gt; th:
        return True
    else:
        return False

def mbs_detector(x, fs, fc, bw, th, N):
    # Apply bandpass filter for each band
    s_out = np.zeros(len(x))
    for i in range(N):
        b, a = signal.butter(4, [fc[i]-bw[i]/2, fc[i]+bw[i]/2], btype='band')
        s_out_band = signal.filtfilt(b, a, x)
        # Rectify and low-pass filter
        s_out_band = np.abs(s_out_band)
        b, a = signal.butter(4, 2 * fc[i] / fs, btype='low')
        s_out_band = signal.filtfilt(b, a, s_out_band)
        # Add the envelope output of the current band to the final output
        s_out += s_out_band
    # Thresholding
    if np.max(s_out) &gt; th:
        return True
    else:
        return False
</code></pre><h2 id="conclusion">Conclusion</h2><p>In summary, non-linear detectors like the Sequentially Cyclic (SC) detector and its variants (Quadrature SC Detector, Multi-Stage SC Detector, Multi-Band SC Detector) are widely used in communication systems for detecting the presence of a signal in noise. The SC detector works by multiplying the input signal with a sawtooth waveform and filtering the output signal to obtain the envelope. The envelope is compared to a threshold to determine the presence of a signal.</p><p>We have detailed the statistics and equations for the SC detector and its variants, along with Python implementation for each variant. These detectors have practical applications in various areas of signal processing, such as communications, radar, and medical imaging.</p><hr> <side style="font-size: 0.9em"><h3 style="margin-bottom: 1em">Notes mentioning this note</h3><div style="font-size: 0.9em"><p> There are no notes linking to this note.</p></div></side> <a href="" class="post-link"><h2></h2><p class="post-excerpt"></p></a> <script src="https://giscus.app/client.js" data-repo="pavandonthireddy/pavandonthireddy.github.io" data-repo-id="[ENTER REPO ID HERE]" data-category="[ENTER CATEGORY NAME HERE]" data-category-id="[ENTER CATEGORY ID HERE]" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="light_high_contrast" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></section></main></body></html>
