<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Weiner Filtering and its Variants" /><meta name="author" content="Pavan Donthireddy" /><meta property="og:locale" content="en_US" /><meta name="description" content="An overview of Weiner Filtering and its variations with Python implementation and examples." /><meta property="og:description" content="An overview of Weiner Filtering and its variations with Python implementation and examples." /><link rel="canonical" href="http://localhost:4000/2023/04/03/weiner-filtering" /><meta property="og:url" content="http://localhost:4000/2023/04/03/weiner-filtering" /><meta property="og:site_name" content="Pavan Donthireddy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-03T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Weiner Filtering and its Variants" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Pavan Donthireddy" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pavan Donthireddy"},"dateModified":"2023-04-03T00:00:00+01:00","datePublished":"2023-04-03T00:00:00+01:00","description":"An overview of Weiner Filtering and its variations with Python implementation and examples.","headline":"Weiner Filtering and its Variants","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/04/03/weiner-filtering"},"url":"http://localhost:4000/2023/04/03/weiner-filtering"}</script><title> Weiner Filtering and its Variants - Pavan Donthireddy</title><meta charset="UTF-8"><link rel="canonical" href="http://localhost:4000/2023/04/03/weiner-filtering" /><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Introduction"><meta property="og:site_name" content="Pavan Donthireddy"><meta property="og:description" content="Introduction"/><meta property="og:title" content="Weiner Filtering and its Variants"><meta property="og:type" content="article"><meta property="article:published_time" content="2023-04-03T00:00:00+01:00"><meta property="article:author" content="http://localhost:4000/"><meta property="og:url" content="http://localhost:4000/2023/04/03/weiner-filtering" /><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Pavan Donthireddy" href="/atom.xml"><link rel="alternate" type="application/json" title="Pavan Donthireddy" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX","input/MathML","output/SVG", "output/CommonHTML"], extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "CHTML-preview.js"], TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }, tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, messageStyle: "none", "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }, TeX: { equationNumbers: { autoNumber: "AMS" }, extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js"], TagSide: "left", Macros: { field: ['\\mathbb{#1}', 1], C: ['\\field{C}'], E: ['\\field{E}'], F: ['\\field{F}'], N: ['\\field{N}'], P: ['\\field{P}'], Q: ['\\field{Q}'], R: ['\\field{R}'], Z: ['\\field{Z}'], ha : ['\\hat{#1}',1], Re: ['\\mathop{\\mathrm{Re}}'], Im: ['\\mathop{\\mathrm{Im}}'], Res: ['\\mathop{\\mathrm{Res}}'], } } }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.post-archive{font-size:15px;line-height:2;padding-bottom:.8em}.post-archive .date{padding-right:.7em}.pagination{width:100%;padding:0 20px;text-align:center}.pagination ul{list-style:none}.pagination ul li{display:inline;margin:0 5px}.pagination ul li a{color:#000;text-decoration:none}.pagination ul li a:hover{color:gray;text-decoration:underline}.pagination ul li.current-page a{background:#ddd;color:#fff}.post-link{position:relative;display:inline-block}.post-excerpt{display:none;position:absolute;z-index:1;top:100%;left:0;width:100%;padding:10px;background-color:#fff;box-shadow:0 2px 5px rgba(0,0,0,.1)}.post-link:hover .post-excerpt{display:block}.img-padding{width:200px;height:200px;padding:20px 20px 20px 20px}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">Pavan Donthireddy</h1>--><nav role="navigation"><ul><li><a href="/" >Notes</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search" >Search</a></li><li><a href="/about" >About</a></li></ul></nav></header><link rel="stylesheet" href="/assets/js/prism.css"><link rel="stylesheet" href="/assets/js/prism-line-numbers.css"><section class="post"> <script src="/assets/js/prism.js"></script> <script src="/assets/js/prism-line-numbers.js"></script><h1 style="text-align: center;">Weiner Filtering and its Variants</h1><div style="text-align: center;"><span class="meta"><time datetime="2023-04-03T00:00:00+01:00">April 3, 2023</time> </span></div><div style="text-align: center;"><span class="meta"> <a href="/tag/noise">noise</a>, <a href="/tag/filters">filters</a></span></div><h1 id="introduction">Introduction</h1><p>In signal processing, noise reduction is a crucial aspect, especially when the signal carries the relevant information. Weiner Filtering is one of the most widely used techniques to reduce noise in the signal processing domain. This technique estimates the original signal from the corrupted or noisy signal using an optimal linear filter. Weiner Filtering is useful when the underlying signal is corrupted with additive random noise.</p><h1 id="weiner-filter">Weiner Filter</h1><p>Weiner Filtering is based on the observation that the corrupted signal can be expressed as the sum of the original signal and the noise signal. This can be represented mathematically as: \(y(n) = x(n) + v(n)\)</p><p>Where y(n) is the corrupted signal, x(n) is the original signal, and v(n) is the noise.</p><p>The goal of Weiner Filtering is to estimate the original signal x(n) from y(n). To do this, we can estimate x(n) using the following equation:</p>\[\hat{x}(n) = \sum_{m = -\infty}^{+\infty} h(m)y(n - m)\]<p>Where <strong>h(m)</strong> is the filter coefficients, and $\hat{x}(n)$ is the estimated value of <strong>x(n)</strong>.</p><p>The primary goal in Weiner Filtering is to find the optimal filter coefficients <strong>h(m)</strong> that minimize the mean-square error between the original signal <strong>x(n)</strong> and estimated signal $\hat{x}(n)$.</p><p>The optimal filter coefficients <strong>h(m)</strong> can be obtained by minimizing the mean-square error between the original signal <strong>x(n)</strong> and the estimated signal $\hat{x}(n)$ using the Wiener-Hopf equation:</p>\[R_{xx}(k)h(k) = R_{xy}(k)\]<p>Where <strong>R<sub>xx</sub>(k)</strong> is the auto-correlation sequence of x(n), <strong>R<sub>xy</sub>(k)</strong> is the cross-correlation sequence between x(n) and y(n), and h(k) is the filter coefficient at k-th position.</p><p>Once we obtain the optimal filter coefficients <strong>h(m)</strong> from the <strong>Wiener-Hopf equation</strong>, we can use these coefficients to estimate the original signal <strong>x(n)</strong>.</p><h2 id="python-implementation">Python Implementation</h2><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">scipy.signal</span> <span class="kn">import</span> <span class="n">lfilter</span><span class="p">,</span> <span class="n">correlate</span>
<span class="kn">from</span> <span class="n">scipy.io</span> <span class="kn">import</span> <span class="n">wavfile</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">wiener_filter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">SNR</span><span class="p">):</span>
    <span class="s">'''
    y: Noisy input signal
    noise: Noise signal to be removed
    SNR: Signal to noise ratio

    Returns:
    The processed signal
    '''</span>
    <span class="c1"># Compute the power of noisy and noise signals
</span>    <span class="n">noise_power</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">noise</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">signal_power</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Compute noise-to-signal ratio
</span>    <span class="n">snr</span> <span class="o">=</span> <span class="n">signal_power</span> <span class="o">/</span> <span class="n">noise_power</span>

    <span class="c1"># Compute filter coefficients using Wiener-Hopf equation
</span>    <span class="n">h</span> <span class="o">=</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'same'</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">noise</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">y_filtered</span> <span class="o">=</span> <span class="nf">lfilter</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y_filtered</span>
</code></pre></div></div><h1 id="variations-of-weiner-filter">Variations of Weiner Filter</h1><h2 id="minimum-mean-square-error-mmse-weiner-filter">Minimum Mean-Square Error (MMSE) Weiner Filter</h2><p>The Minimum Mean-Square Error (MMSE) Weiner Filter is an extension of the conventional Weiner Filter. In the conventional Weiner Filter, we aim to minimize the mean-square error between the original signal and the estimated signal. In contrast, MMSE Weiner filter aims to minimize the mean-square error between the original signal and the estimated signal, considering the distortion introduced by the filter.</p><p>The MMSE filter optimizes the filter coefficients to reduce both noise and distortion. The MMSE filter accounts for both the noise and the signal’s statistics, and it tries to minimize the error with respect to the noisy signal.</p><p>The formula for computing the MMSE filter coefficients is given below:</p>\[h_{MMSE} = \frac{R_{xx}^{-1}(R_{xx} + R_{vv})}{R_{xx}^{-1}}\]<p>where <strong>R<sub>xx</sub></strong> is the auto-correlation matrix of the input signal, and <strong>R<sub>vv</sub></strong> is the auto-correlation matrix of the noise signal.</p><h2 id="least-mean-square-lms-weiner-filter">Least Mean-Square (LMS) Weiner Filter</h2><p>The Least Mean-Square (LMS) Weiner Filter is a variant of the Weiner filter that is used when there is a limited amount of data or a non-stationary signal. The LMS filter uses a gradient descent algorithm to iteratively compute the filter coefficients.</p><p>Unlike the Weiner filter, the LMS filter does not require the input signal’s auto-correlation matrix. Instead, it updates the filter coefficients based on the difference between the noisy input signal and the estimated signal.</p><p>The formula to update the filter coefficients is given by:</p>\[h(n+1)=h(n)+2\mu e(n)y(n)\]<p>Where h(n+1) is the updated filter coefficients, $\mu$ is the step size, e(n) is the error signal, and y(n) is the filtered output.</p><h2 id="python-implementation-1">Python Implementation</h2><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mmse_filter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">noise</span><span class="p">):</span>
    <span class="s">'''
    y: Noisy input signal
    noise: Noise signal to be removed

    Returns:
    The processed signal
    '''</span>
    <span class="c1"># Compute the power of the signal and noise
</span>    <span class="n">noise_power</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">noise</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">signal_power</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Estimate the auto-correlation matrices
</span>    <span class="n">Rx</span> <span class="o">=</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'same'</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">Rv</span> <span class="o">=</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'same'</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>

    <span class="c1"># Compute the MMSE Wiener Filter coefficients
</span>    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">inv</span><span class="p">(</span><span class="n">Rx</span> <span class="o">+</span> <span class="n">Rv</span><span class="p">),</span> <span class="n">Rx</span><span class="p">)</span>

    <span class="n">y_filtered</span> <span class="o">=</span> <span class="nf">lfilter</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y_filtered</span>

<span class="k">def</span> <span class="nf">lms_filter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">n_taps</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">n_iterations</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="s">'''
    y: Noisy input signal
    noise: Noise signal to be removed
    n_taps: Number of filter coefficients
    step_size: Learning rate or step size
    n_iterations: Number of iterations

    Returns:
    The processed signal
    '''</span>
  
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">n_taps</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_iterations</span><span class="p">):</span>
        <span class="c1"># Compute the current filter output
</span>        <span class="n">y_filtered</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">convolve</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'same'</span><span class="p">)</span>

        <span class="c1"># Compute the error signal
</span>        <span class="n">e</span> <span class="o">=</span> <span class="n">noise</span> <span class="o">-</span> <span class="n">y_filtered</span>

        <span class="c1"># Update filter coefficients
</span>        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">step_size</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">convolve</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'same'</span><span class="p">)</span>
    
    <span class="n">y_filtered</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">convolve</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'same'</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">y_filtered</span>
</code></pre></div></div><h1 id="conclusion">Conclusion</h1><p>Weiner Filtering is an optimal linear filtering technique that is widely used in the signal processing domain. It estimates the original signal from the corrupted or noisy signal by finding the optimal filter coefficients that minimize the mean-square error between the original signal and estimated signal.</p><p>In this article, we discussed the conventional Weiner filter, its variations such as MMSE Weiner filter and LMS filter, and provided Python implementations for each. We hope this article helps you gain a basic understanding of Weiner Filtering and its variations.</p><hr> <side style="font-size: 0.9em"><h3 style="margin-bottom: 1em">Notes mentioning this note</h3><div style="font-size: 0.9em"><p> There are no notes linking to this note.</p></div></side> <a href="" class="post-link"><h2></h2><p class="post-excerpt"></p></a> <script src="https://giscus.app/client.js" data-repo="pavandonthireddy/pavandonthireddy.github.io" data-repo-id="[ENTER REPO ID HERE]" data-category="[ENTER CATEGORY NAME HERE]" data-category-id="[ENTER CATEGORY ID HERE]" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="light_high_contrast" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></section></main><div class="center"> <a href='https://ko-fi.com/G2G3KNTHM' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://storage.ko-fi.com/cdn/kofi5.png?v=3' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a></div></body></html>
