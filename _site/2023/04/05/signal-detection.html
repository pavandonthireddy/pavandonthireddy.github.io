<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="The Signal Detection Problem and its Variants" /><meta name="author" content="Pavan Donthireddy" /><meta property="og:locale" content="en_US" /><meta name="description" content="An in-depth examination of signal detection algorithms and their real-time variants, including Python implementations and examples." /><meta property="og:description" content="An in-depth examination of signal detection algorithms and their real-time variants, including Python implementations and examples." /><link rel="canonical" href="http://localhost:4000/2023/04/05/signal-detection" /><meta property="og:url" content="http://localhost:4000/2023/04/05/signal-detection" /><meta property="og:site_name" content="Pavan Donthireddy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-05T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The Signal Detection Problem and its Variants" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Pavan Donthireddy" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pavan Donthireddy"},"dateModified":"2023-04-05T00:00:00+01:00","datePublished":"2023-04-05T00:00:00+01:00","description":"An in-depth examination of signal detection algorithms and their real-time variants, including Python implementations and examples.","headline":"The Signal Detection Problem and its Variants","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/04/05/signal-detection"},"url":"http://localhost:4000/2023/04/05/signal-detection"}</script><title> The Signal Detection Problem and its Variants - Pavan Donthireddy</title><meta charset="UTF-8"><link rel="canonical" href="http://localhost:4000/2023/04/05/signal-detection" /><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Introduction"><meta property="og:site_name" content="Pavan Donthireddy"><meta property="og:description" content="Introduction"/><meta property="og:title" content="The Signal Detection Problem and its Variants"><meta property="og:type" content="article"><meta property="article:published_time" content="2023-04-05T00:00:00+01:00"><meta property="article:author" content="http://localhost:4000/"><meta property="og:url" content="http://localhost:4000/2023/04/05/signal-detection" /><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Pavan Donthireddy" href="/atom.xml"><link rel="alternate" type="application/json" title="Pavan Donthireddy" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX","input/MathML","output/SVG", "output/CommonHTML"], extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "CHTML-preview.js"], TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }, tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, messageStyle: "none", "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }, TeX: { equationNumbers: { autoNumber: "AMS" }, extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js"], TagSide: "left", Macros: { field: ['\\mathbb{#1}', 1], C: ['\\field{C}'], E: ['\\field{E}'], F: ['\\field{F}'], N: ['\\field{N}'], P: ['\\field{P}'], Q: ['\\field{Q}'], R: ['\\field{R}'], Z: ['\\field{Z}'], ha : ['\\hat{#1}',1], Re: ['\\mathop{\\mathrm{Re}}'], Im: ['\\mathop{\\mathrm{Im}}'], Res: ['\\mathop{\\mathrm{Res}}'], } } }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.post-archive{font-size:15px;line-height:2;padding-bottom:.8em}.post-archive .date{padding-right:.7em}.pagination{width:100%;padding:0 20px;text-align:center}.pagination ul{list-style:none}.pagination ul li{display:inline;margin:0 5px}.pagination ul li a{color:#000;text-decoration:none}.pagination ul li a:hover{color:gray;text-decoration:underline}.pagination ul li.current-page a{background:#ddd;color:#fff}.post-link{position:relative;display:inline-block}.post-excerpt{display:none;position:absolute;z-index:1;top:100%;left:0;width:100%;padding:10px;background-color:#fff;box-shadow:0 2px 5px rgba(0,0,0,.1)}.post-link:hover .post-excerpt{display:block}.img-padding{width:200px;height:200px;padding:20px 20px 20px 20px}</style><link rel="stylesheet" href="/_includes/prism.css"> <script src="/assets/js/prism.js"></script></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">Pavan Donthireddy</h1>--><nav role="navigation"><ul><li><a href="/" >Notes</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search" >Search</a></li><li><a href="/about" >About</a></li></ul></nav></header><link rel="stylesheet" href="/assets/js/prism.css"> <script src="/assets/js/prism.js"></script><section class="post"> <script src="/assets/js/prism.js"></script><h1 style="text-align: center;">The Signal Detection Problem and its Variants</h1><div style="text-align: center;"><span class="meta"><time datetime="2023-04-05T00:00:00+01:00">April 5, 2023</time> </span></div><div style="text-align: center;"><span class="meta"> <a href="/tag/signal_detection">signal_detection</a></span></div><h1 id="introduction">Introduction</h1><p>The signal detection problem is a fundamental issue in signal processing, which involves distinguishing between “signal” and “noise” in a given data set. While the term “signal” is often used in the context of communication signals, it can refer to any meaningful pattern or structure in the data, such as a periodic pattern in a traffic flow dataset that indicates the presence of a traffic light.</p><p>Real-time signal detection is particularly challenging since the data is constantly changing, and the algorithms must operate within tight time constraints. This article provides an overview of the key signal detection algorithms and their variants in real-time applications, including their mathematical formulations and Python implementations.</p><h1 id="signal-detection-algorithms">Signal Detection Algorithms</h1><p>Signal detection algorithms classify input data as “signal” or “noise,” often using a statistical approach to distinguish between the two. The most popular algorithms for time-series data include:</p><h2 id="thresholding-method">Thresholding Method</h2><p>The thresholding method is a simple yet effective way to detect signals based on a threshold value. If a time-series value exceeds the threshold, the data is classified as “signal”; otherwise, it is classified as “noise.” The threshold can be static or dynamic, depending on the application.</p><p>The mathematical formulation for thresholding is as follows:</p><p><code class="language-plaintext highlighter-rouge">x(n) = { 1, if s(n) &gt; T; 0, otherwise }</code></p><p>Where <code class="language-plaintext highlighter-rouge">s(n)</code> is the input signal and <code class="language-plaintext highlighter-rouge">T</code> is the threshold value.</p><h3 id="python-implementation">Python Implementation</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">thresholding</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="c1"># Returns a binary signal where 1 indicates a signal value above the threshold, and 0 indicates noise.
</span>    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">signal</span><span class="p">]</span>
</code></pre></div></div><h3 id="example">Example</h3><p>Consider an input signal <code class="language-plaintext highlighter-rouge">s = [0, 1, 3, 2, 4, 3, 1, 0, -1, -3]</code>. We can apply thresholding with a threshold value of <code class="language-plaintext highlighter-rouge">2</code> to identify signal values.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">thresholding</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div><h2 id="moving-average-method">Moving Average Method</h2><p>The moving average method smooths the input signal and detects signals based on the distance between the smoothed signal and the original signal. The method involves calculating the average of the last <code class="language-plaintext highlighter-rouge">N</code> data points in the time-series, where <code class="language-plaintext highlighter-rouge">N</code> is a user-defined window size. The difference between the current value and the moving average is compared against a threshold value. If the difference is greater than the threshold, the data is classified as a signal.</p><p>The mathematical formulation for moving average method is:</p><p><code class="language-plaintext highlighter-rouge">x(n) = { 1, if |s(n) - y(n)| &gt; T; 0, otherwise }</code></p><p>Where <code class="language-plaintext highlighter-rouge">s(n)</code> is the input signal, <code class="language-plaintext highlighter-rouge">y(n)</code> is the moving average signal, and <code class="language-plaintext highlighter-rouge">T</code> is the threshold value.</p><h3 id="python-implementation-1">Python Implementation</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">moving_average</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="c1"># Returns a binary signal where 1 indicates a signal value above the threshold, and 0 indicates noise.
</span>    <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">convolve</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="n">window_size</span><span class="p">,))</span><span class="o">/</span><span class="n">window_size</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">'valid'</span><span class="p">)</span>
    <span class="n">ma_diff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">window_size</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ma</span><span class="p">)</span>
    <span class="n">ma_diff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">window_size</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ma_diff</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ma_diff</span><span class="p">]</span>
</code></pre></div></div><h3 id="example-1">Example</h3><p>Consider the same input signal <code class="language-plaintext highlighter-rouge">s</code> as above. We can apply the moving average method with a window size of <code class="language-plaintext highlighter-rouge">3</code> and a threshold value of <code class="language-plaintext highlighter-rouge">1</code> to identify signal values.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">moving_average</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div><h2 id="autocorrelation-method">Autocorrelation Method</h2><p>The autocorrelation method is based on the principle that the signal should be periodic if it contains a signal component that is repeated over time. The method computes the autocorrelation of the time series signal for multiple lag values and identifies signals based on the maximum value of the autocorrelation.</p><p>The mathematical formulation for the autocorrelation method is:</p><p><code class="language-plaintext highlighter-rouge">x(n) = { 1, if rxx(k) &gt; T; 0, otherwise }</code></p><p>Where <code class="language-plaintext highlighter-rouge">rxx(k)</code> is the autocorrelation for lag <code class="language-plaintext highlighter-rouge">k</code> and <code class="language-plaintext highlighter-rouge">T</code> is the threshold value.</p><h3 id="python-implementation-2">Python Implementation</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">autocorrelation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="c1"># Returns a binary signal where 1 indicates a signal value above the threshold, and 0 indicates noise.
</span>    <span class="n">nx</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">autocorrelations</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="n">autocorrelations</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">corrcoef</span><span class="p">(</span><span class="n">signal</span><span class="p">[:</span><span class="o">-</span><span class="n">k</span><span class="p">],</span> <span class="n">signal</span><span class="p">[</span><span class="n">k</span><span class="p">:])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">autocorrelations</span><span class="p">]</span>
</code></pre></div></div><h3 id="example-2">Example</h3><p>Consider the same input signal <code class="language-plaintext highlighter-rouge">s</code> as above. We can apply the autocorrelation method with a threshold value of <code class="language-plaintext highlighter-rouge">0.5</code> to identify signal values.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">autocorrelation</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div><h1 id="real-time-variants">Real-time Variants</h1><p>Real-time signal detection requires that the algorithms operate efficiently and effectively within the constraints of the system. The following are some variants of the signal detection algorithms that are suitable for real-time applications.</p><h2 id="sliding-window-method">Sliding Window Method</h2><p>The sliding window method is a real-time variant of the moving average method, which computes the moving average for a fixed window size as the data arrives. The window is moved to the right with each new data point, and the moving average is computed again. The method detects signals based on the difference between the current value and the moving average using a threshold.</p><p>The mathematical formulation is the same as the moving average method.</p><h3 id="python-implementation-3">Python Implementation</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sliding_window</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="c1"># Returns a binary signal where 1 indicates a signal value above the threshold, and 0 indicates noise.
</span>    <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">-</span><span class="n">window_size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">window_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)):</span>
        <span class="n">ma</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">window_size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">window_size</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ma_diff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">window_size</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">ma</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ma_diff</span><span class="p">]</span>
</code></pre></div></div><h3 id="example-3">Example</h3><p>Consider the input signal <code class="language-plaintext highlighter-rouge">s = [2, 3, 1, 5, 2, 1, 3, 2]</code>. We can apply the sliding window method with a window size of <code class="language-plaintext highlighter-rouge">3</code> and a threshold value of <code class="language-plaintext highlighter-rouge">1</code> to identify signal values.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">sliding_window</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div><h2 id="recursive-moving-average-method">Recursive Moving Average Method</h2><p>The recursive moving average method is a real-time variant of the moving average method that computes the moving average as new data points are received. The method uses a recursive formula to update the moving average, which allows for efficient and real-time processing of data. The method detects signals based on the difference between the current value and the moving average using a threshold.</p><p>The mathematical formulation is the same as the moving average method.</p><h3 id="python-implementation-4">Python Implementation</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recursive_moving_average</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="c1"># Returns a binary signal where 1 indicates a signal value above the threshold, and 0 indicates noise.
</span>    <span class="n">ma</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)):</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">ma</span> <span class="o">+</span> <span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ma</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ma_diff</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">ma</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ma_diff</span><span class="p">]</span>
</code></pre></div></div><h3 id="example-4">Example</h3><p>Consider the same input signal <code class="language-plaintext highlighter-rouge">s</code> as before. We can apply the recursive moving average method with a threshold value of <code class="language-plaintext highlighter-rouge">1</code> to identify signal values.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">recursive_moving_average</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div><h2 id="cusum-method">CUSUM Method</h2><p>The CUSUM method is a real-time variant of the thresholding method that detects changes in the signal over time. The method computes the cumulative sum of the differences between the actual signal and the expected signal. The expected signal is determined by an initial reference value, which is updated after each data point is received. The method detects signals based on the cumulative sum exceeding a threshold.</p><p>The mathematical formulation for the CUSUM method is:</p><p><code class="language-plaintext highlighter-rouge">x(n) = { 1, if cumsum(n) - k &gt; T; 0, otherwise }</code></p><p>Where <code class="language-plaintext highlighter-rouge">cumsum(n)</code> is the cumulative sum of the differences between the actual signal and the expected signal up to time <code class="language-plaintext highlighter-rouge">n</code>. <code class="language-plaintext highlighter-rouge">k</code> is an offset threshold, and <code class="language-plaintext highlighter-rouge">T</code> is a drift threshold.</p><h3 id="python-implementation-5">Python Implementation</h3><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cusum</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">drift</span><span class="p">):</span>
    <span class="c1"># Returns a binary signal where 1 indicates a signal value above the threshold, and 0 indicates noise.
</span>    <span class="n">expected</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cumsum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)):</span>
        <span class="n">expected</span> <span class="o">+=</span> <span class="n">k</span>
        <span class="n">cumsum</span> <span class="o">+=</span> <span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">expected</span>
        <span class="k">if</span> <span class="n">cumsum</span> <span class="o">&gt;</span> <span class="n">drift</span><span class="p">:</span>
            <span class="n">cumsum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">signal</span><span class="p">))]</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
</code></pre></div></div><h3 id="example-5">Example</h3><p>Consider the input signal <code class="language-plaintext highlighter-rouge">s = [1.2, 1.5, 1.3, 1.8, 1.7, 1.6, 1.8, 1.5, 1.2]</code>. We can apply the CUSUM method with <code class="language-plaintext highlighter-rouge">k = 0.2</code> and <code class="language-plaintext highlighter-rouge">drift = 0.4</code> to identify signal values.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">cusum</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div><h1 id="conclusion">Conclusion</h1><p>Real-time signal detection is a fundamental challenge in signal processing, and various algorithms and their variants have been proposed to address this issue. This article provided an overview of the key algorithms and their real-time variants, along with mathematical formulations and Python implementations. These methods provide a range of approaches for detecting signals and can be used in various applications, including biometric authentication, motion and activity recognition, and fault detection in industrial processes.</p><hr> <side style="font-size: 0.9em"><h3 style="margin-bottom: 1em">Notes mentioning this note</h3><div style="font-size: 0.9em"><p> There are no notes linking to this note.</p></div></side> <a href="" class="post-link"><h2></h2><p class="post-excerpt"></p></a> <script src="https://giscus.app/client.js" data-repo="pavandonthireddy/pavandonthireddy.github.io" data-repo-id="[ENTER REPO ID HERE]" data-category="[ENTER CATEGORY NAME HERE]" data-category-id="[ENTER CATEGORY ID HERE]" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="light_high_contrast" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></section></main></body></html>
