<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Intrinsic Chirp Component Decomposition and its Variants" /><meta name="author" content="Pavan Donthireddy" /><meta property="og:locale" content="en_US" /><meta name="description" content="This article discusses the theoretical concept of intrinsic chirp component decomposition along with its variants." /><meta property="og:description" content="This article discusses the theoretical concept of intrinsic chirp component decomposition along with its variants." /><link rel="canonical" href="http://localhost:4000/2023/03/28/intrinsic-chirp-component-decomposition" /><meta property="og:url" content="http://localhost:4000/2023/03/28/intrinsic-chirp-component-decomposition" /><meta property="og:site_name" content="Pavan Donthireddy" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-28T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Intrinsic Chirp Component Decomposition and its Variants" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@Pavan Donthireddy" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Pavan Donthireddy"},"dateModified":"2023-03-28T00:00:00+01:00","datePublished":"2023-03-28T00:00:00+01:00","description":"This article discusses the theoretical concept of intrinsic chirp component decomposition along with its variants.","headline":"Intrinsic Chirp Component Decomposition and its Variants","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/03/28/intrinsic-chirp-component-decomposition"},"url":"http://localhost:4000/2023/03/28/intrinsic-chirp-component-decomposition"}</script><title> Intrinsic Chirp Component Decomposition and its Variants - Pavan Donthireddy</title><meta charset="UTF-8"><link rel="canonical" href="http://localhost:4000/2023/03/28/intrinsic-chirp-component-decomposition" /><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Introduction"><meta property="og:site_name" content="Pavan Donthireddy"><meta property="og:description" content="Introduction"/><meta property="og:title" content="Intrinsic Chirp Component Decomposition and its Variants"><meta property="og:type" content="article"><meta property="article:published_time" content="2023-03-28T00:00:00+01:00"><meta property="article:author" content="http://localhost:4000/"><meta property="og:url" content="http://localhost:4000/2023/03/28/intrinsic-chirp-component-decomposition" /><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="Pavan Donthireddy" href="/atom.xml"><link rel="alternate" type="application/json" title="Pavan Donthireddy" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ jax: ["input/TeX","input/MathML","output/SVG", "output/CommonHTML"], extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "CHTML-preview.js"], TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] }, tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }, messageStyle: "none", "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }, TeX: { equationNumbers: { autoNumber: "AMS" }, extensions: ["AMSmath.js", "AMSsymbols.js","AMScd.js"], TagSide: "left", Macros: { field: ['\\mathbb{#1}', 1], C: ['\\field{C}'], E: ['\\field{E}'], F: ['\\field{F}'], N: ['\\field{N}'], P: ['\\field{P}'], Q: ['\\field{Q}'], R: ['\\field{R}'], Z: ['\\field{Z}'], ha : ['\\hat{#1}',1], Re: ['\\mathop{\\mathrm{Re}}'], Im: ['\\mathop{\\mathrm{Im}}'], Res: ['\\mathop{\\mathrm{Res}}'], } } }); </script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code,pre{background:#ecedee}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.post-archive{font-size:15px;line-height:2;padding-bottom:.8em}.post-archive .date{padding-right:.7em}.pagination{width:100%;padding:0 20px;text-align:center}.pagination ul{list-style:none}.pagination ul li{display:inline;margin:0 5px}.pagination ul li a{color:#000;text-decoration:none}.pagination ul li a:hover{color:gray;text-decoration:underline}.pagination ul li.current-page a{background:#ddd;color:#fff}.post-link{position:relative;display:inline-block}.post-excerpt{display:none;position:absolute;z-index:1;top:100%;left:0;width:100%;padding:10px;background-color:#fff;box-shadow:0 2px 5px rgba(0,0,0,.1)}.post-link:hover .post-excerpt{display:block}.img-padding{width:200px;height:200px;padding:20px 20px 20px 20px}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">Pavan Donthireddy</h1>--><nav role="navigation"><ul><li><a href="/" >Notes</a></li><li><a href="/tags" >Tags</a></li><li><a href="/search" >Search</a></li><li><a href="/about" >About</a></li></ul></nav></header><section class="post"><h1 style="text-align: center;">Intrinsic Chirp Component Decomposition and its Variants</h1><div style="text-align: center;"><span class="meta"><time datetime="2023-03-28T00:00:00+01:00">March 28, 2023</time> </span></div><div style="text-align: center;"><span class="meta"> <a href="/tag/time_frequency_methods">time_frequency_methods</a>, <a href="/tag/ICCD">ICCD</a>, <a href="/tag/signal_extraction">signal_extraction</a></span></div><h1 id="introduction">Introduction</h1><p>The intrinsic chirp component (ICC) is a time-frequency component present in a signal that has been widely studied in the field of time-frequency analysis. The decomposition of a signal into its ICC and non-ICC components can provide insight into its underlying structure and aid in the extraction of meaningful information.</p><p>In this article, we will discuss the theoretical concept of intrinsic chirp component decomposition along with its variants. We will also provide Python implementations and examples for each variant.</p><h1 id="intrinsic-chirp-component-decomposition">Intrinsic Chirp Component Decomposition</h1><p>Intrinsic Chirp Component Decomposition (ICCD) is a technique used to extract the ICC(s) of a signal. The concept behind the ICC is simple: At any instant of time, the signal is analyzed using a time-frequency window. In a standard Fourier transform, this window is fixed and its length becomes shorter for high frequencies. However, the ICC approach employs a time-frequency window that varies with time, such that the windowâ€™s size increases for high frequencies. Therefore, ICC is a non-stationary feature that varies with time, unlike Fourier-based methods, which are stationary features.</p><p>The general equation for ICCD is:</p>\[x(t) = ICC(t) + x_{0}(t)\]<p>where $x(t)$ is the signal, $ICC(t)$ is the Intrinsic Chirp Component, and $x_0(t)$ is the non-ICC component.</p><p>ICC(t) is defined as follows:</p>\[ICC(t) = \int_{-\infty}^{\infty}\int_{-\infty}^{\infty}W(t,f)\,f\,dt\,df\]<p>where $W(t,f)$ is the short-time Fourier transform of the signal, and $f$ is the frequency component.</p><p>ICC can be used to characterize several properties of the signal, including its time-varying spectral profile, complexity, and phase structure. The decomposition of the signal into the ICC and non-ICC components can help extract meaningful information from the signal.</p><p>A Python implementation of ICCD is as follows:</p><pre><code>def iccd(x, fs):
    N = len(x)
    f, t, stft = signal.stft(x, fs)
    
    ICC = np.sum(stft*f, axis=0)
    noICC = stft - np.outer(f, ICC)

    return ICC, noICC
</code></pre><p>Here, <code>x</code> is the input signal, and <code>fs</code> is its sampling frequency. We compute the short-time Fourier transform using the <code>signal.stft</code> function from <code>scipy</code> library, then calculate the ICC and noICC components using the equations described earlier.</p><h1 id="variants-of-iccd">Variants of ICCD</h1><p>Several variants of ICCD can be used based on the properties required from the signal. Here are three variants:</p><h2 id="amplitude-modulation-decomposition">Amplitude Modulation Decomposition</h2><p>In this variant, we decompose a signal into its amplitude modulation components, which are related to the ICC feature. The equation for amplitude modulation decomposition is:</p>\[x(t) = \sum_{a=1}^{M} a(t)\,C_{a}(t) + x_{0}(t)\]<p>where $a(t)$ is the amplitude modulation envelope, $C_a(t)$ is the $a^{\text{th}}$ intrinsic chirp component, and $M$ is the number of ICCs.</p><p>The Python implementation of this variant is:</p><pre><code>def ampd(x, fs, M):
    N = len(x)
    f, t, stft = signal.stft(x, fs)
    
    am = np.sum(np.abs(stft), axis=0)
    noAMP = stft / np.outer(am, np.ones(N))

    ICCs = []
    for i in range(M):
        C = np.sum(noAMP * (np.abs(stft) ** i), axis=0)
        ICCs.append(C)
        noAMP = noAMP - np.outer(C, (am ** i))

    return np.array(ICCs), noAMP
</code></pre><p>Here, <code>M</code> is the number of ICCs we want to extract. We compute the short-time Fourier transform and calculate the amplitude modulation envelope. We then calculate the ICC components by iteratively subtracting the ICC components from the non-ICC component.</p><h2 id="frequency-modulation-decomposition">Frequency Modulation Decomposition</h2><p>In this variant, we decompose a signal into its frequency modulation components, which are related to the derivative of the ICC feature. The equation for frequency modulation decomposition is:</p>\[x(t) = \sum_{a=1}^{M} b_a(t)\,F_{a}(t) + x_{0}(t)\]<p>where $b_a(t)$ is the frequency modulation envelope, $F_{a}(t)$ is the $a^{\text{th}}$ derivative of the ICC, and $M$ is the number of ICCs.</p><p>The Python implementation of this variant is:</p><pre><code>def fmdp(x, fs, M):
    N = len(x)
    f, t, stft = signal.stft(x, fs)
    
    fm = np.sum((f[:, np.newaxis] - np.mean(f)) ** 2 * np.abs(stft) ** 2, axis=0)
    noFMP = stft / np.outer(np.ones(N), np.sqrt(fm))

    ICCs = []
    for i in range(M):
        F = np.sum(noFMP * ((f[:, np.newaxis]-np.mean(f))**i)*np.abs(stft)**2, axis=0) / fm
        ICCs.append(F)
        noFMP = noFMP - np.outer(ICC, (f[:, np.newaxis]-np.mean(f)) ** i)
    
    return np.array(ICCs), noFMP
</code></pre><p>Here, <code>M</code> is the number of ICCs we want to extract. We compute the short-time Fourier transform and calculate the frequency modulation envelope. We then calculate the ICC components by iteratively subtracting the ICC components from the non-ICC component.</p><h2 id="synchrosqueezing-transform">Synchrosqueezing Transform</h2><p>In this variant, we apply the Synchrosqueezing Transform (SST) to the signal, which is a modified version of the Fourier transform that concentrates the energy of the signal onto the ICCs. The equation for SST is:</p>\[S\{\gamma_f h(t)\}(t, f) = \frac{h(t)\,\overline{h(t)}}{\int_{0}^{\infty}|h(t)|^2\,dt}\,w(t, f)\]<p>where $\gamma_f$ is the frequency scaling factor, $h(t)$ is the signal, $w(t, f)$ is the wavelet, and $S$ is the synchrosqueezing operator.</p><p>The Python implementation of this variant is:</p><pre><code>def sst(x, fs):
    N = len(x)
    f, stft = scipy.signal.stft(x, fs)

    M = np.shape(stft)[0]
    ICs = np.zeros((M, len(f)))

    for i in range(M):
        w = synchrosqueezing_window(f, i, fs)
        ICs[i] = np.sum(stft*w, axis=1)

    return ICs
</code></pre><p>Here, we calculate the short-time Fourier transform using the <code>scipy.signal.stft</code> function. We then calculate the synchrosqueezing window using a custom-defined function <code>synchrosqueezing_window</code>. We calculate the ICC components using the synchrosqueezing operator and return the matrix of the ICC components.</p><h1 id="conclusion">Conclusion</h1><p>In this article, we discussed the concept of intrinsic chirp component decomposition and its variants. We provided equations and Python implementations for each variant, along with examples. ICCD and its variants are powerful tools for extracting information from a given signal, and they have several applications in signal processing, such as in speech recognition, image analysis, and bio-medical signal processing.</p><hr> <side style="font-size: 0.9em"><h3 style="margin-bottom: 1em">Notes mentioning this note</h3><div style="font-size: 0.9em"><p> There are no notes linking to this note.</p></div></side> <a href="" class="post-link"><h2></h2><p class="post-excerpt"></p></a> <script src="https://giscus.app/client.js" data-repo="pavandonthireddy/pavandonthireddy.github.io" data-repo-id="[ENTER REPO ID HERE]" data-category="[ENTER CATEGORY NAME HERE]" data-category-id="[ENTER CATEGORY ID HERE]" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="light_high_contrast" data-lang="en" data-loading="lazy" crossorigin="anonymous" async> </script></section></main></body></html>
