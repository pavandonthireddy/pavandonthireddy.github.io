---
layout: post
title: Non-Linear Detectors like SC Detector and its Variants
description: This article explains Non-Linear Detectors like SC Detector and its Variants with Statistics and Equations in LaTeX. It also includes Python Implementation for all Variants.
summary: Detailed scientific article on Non-Linear Detectors like SC Detector and its Variants with Statistics and Equations in LaTeX, along with Python Implementation for all Variants.
author: Pavan Donthireddy
usemathjax: true
original: new
tags: [ signal_detection ]
---

## Introduction

Non-linear detectors play an important role in signal processing applications. They are used in various applications, such as communications, radar, and medical imaging. The non-linear detectors are classified into two categories, namely parametric and non-parametric detectors. The parametric detectors require knowledge of the signal statistics, whereas the non-parametric detectors do not require any statistical information about the signals.

 One popular non-linear detector is the Sequentially Cyclic (SC) detector (also known as the Sawtooth detector), which is widely used in communication systems. In this article, we will discuss the SC detector in detail, along with its variants and their statistics and equations in LaTeX. Additionally, we will include Python implementation for all variants. 

## SC Detector

The Sequentially Cyclic (SC) detector is a non-linear detector used for detecting the presence of a signal of known frequency in noise. It is a simple but effective detector that is widely used in communication systems. The SC detector works by multiplying the input signal with a reference signal, which is a sawtooth waveform with the same frequency as the input signal. The sawtooth waveform is generated by a voltage-controlled oscillator (VCO), as shown in Figure 1.

![SC Detector Block Diagram](https://i.imgur.com/dsw5V7O.png)

*Figure 1: Block Diagram of SC Detector*

The output of the multiplier is a sum of harmonics of the input signal frequency, which is filtered by a bandpass filter (BPF) centered at the input frequency. The output of the BPF is then rectified and low-pass filtered (LPF) to obtain the Envelope of the input signal, as shown in Figure 2.

![SC Detector Output Waveforms](https://i.imgur.com/2ZQURWd.png)

*Figure 2: SC Detector Output Waveforms*

The envelope output is compared to a threshold, which is set according to the noise level. If the envelope output exceeds the threshold, it is considered as a signal present.

## SC Detector Variants

There are several variants of the SC detector, which are listed below:

### Quadrature SC Detector (QSCD)

The Quadrature SC Detector (QSCD) is a variant of the SC detector that uses two reference signals, which are in-phase and quadrature-phase (I/Q) with the input signal. The reference signals are generated by two voltage-controlled oscillators (VCOs), as shown in Figure 3.

![QSCD Block Diagram](https://i.imgur.com/65Fcgs0.png)

*Figure 3: Block Diagram of QSCD*

The output of the QSCD is obtained by adding the envelope outputs of the I and Q channels. The threshold for the QSCD is set according to the noise level.

### Multi-Stage SC Detector (MSSCD)

The Multi-Stage SC Detector (MSSCD) is a variant of the SC detector that uses multiple stages of bandpass filtering to suppress noise. The MSSCD works by bandpass filtering the input signal at multiple stages, as shown in Figure 4.

![MSSCD Block Diagram](https://i.imgur.com/gtDfHtI.png)

*Figure 4: Block Diagram of MSSCD*

The output of each stage is rectified and low-pass filtered, and then added to obtain the final output. The threshold for the MSSCD is set according to the noise level.

### Multi-Band SC Detector (MBSCD)

The Multi-Band SC Detector (MBSCD) is a variant of the SC detector that uses multiple bandpass filters to separate the input signal into multiple frequency bands. The MBSCD works by splitting the input signal into multiple frequency bands using bandpass filters, as shown in Figure 5.

![MBSCD Block Diagram](https://i.imgur.com/Yc3W6Oe.png)

*Figure 5: Block Diagram of MBSCD*

The output of each bandpass filter is rectified and low-pass filtered, and then added to obtain the final output. The threshold for the MBSCD is set according to the noise level.

## Statistics and Equations

In this section, we will discuss the statistics and equations for the SC detector and its variants.

### SC Detector

The output of the SC detector is given by:

$$S_{out} = \sqrt{2}A_I\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}A_Q\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + N(t)$$

where $J_n(B)$ is the Bessel function of the first kind and order $n$, $B$ is the modulation index, $A_I$ and $A_Q$ are the amplitudes of the I and Q channels, $\omega_0$ is the frequency of the input signal, $t$ is time, and $N(t)$ is the Gaussian noise.

The envelope output of the SC detector is given by:

$$E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + \sqrt{(N(t))^2}$$

where $\phi_n$ and $\psi_n$ are the phases of the I and Q channels, respectively.

The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the SC detector are given by:

$$P_D = Q(\frac{\gamma - d^2}{2\sigma})$$

$$P_{FA} = Q(\frac{\gamma}{2\sigma})$$

where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.

### QSCD

The output of the QSCD is given by:

$$S_{out} = \sqrt{2}A_I\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}A_Q\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + N(t)$$

The envelope output of the QSCD is given by:

$$E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)cos(\omega_0 nt + \phi_n) + \sqrt{2}\sum_{n=-\infty}^{\infty} J_n(B)sin(\omega_0 nt + \psi_n) + \sqrt{(N(t))^2}$$

The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the QSCD are given by:

$$P_D = Q(\frac{\gamma - d^2}{2\sigma})$$

$$P_{FA} = Q(\frac{\gamma}{2\sigma})$$

where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.

### MSSCD

The output of the MSSCD is given by:

$$S_{out} = \sum_{i=1}^{N} \sqrt{2}A_i\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + N(t)$$

The envelope output of the MSSCD is given by:

$$E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{i=1}^{N}\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + \sqrt{(N(t))^2}$$

The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the MSSCD are given by:

$$P_D = Q(\frac{\gamma - d^2}{2\sigma})$$

$$P_{FA} = Q(\frac{\gamma}{2\sigma})$$

where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.

### MBSCD

The output of the MBSCD is given by:

$$S_{out} = \sum_{i=1}^{N} \sqrt{2}A_i\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + N(t)$$

The envelope output of the MBSCD is given by:

$$E(t) = \sqrt{(S_{out})^2} = \sqrt{2}\sum_{i=1}^{N}\sum_{n=-\infty}^{\infty} J_n(B_i)cos(\omega_{0i} nt + \phi_{ni}) + \sqrt{(N(t))^2}$$

The detection probability ($P_D$) and false alarm probability ($P_{FA}$) of the MBSCD are given by:

$$P_D = Q(\frac{\gamma - d^2}{2\sigma})$$

$$P_{FA} = Q(\frac{\gamma}{2\sigma})$$

where $\gamma$ is the detection threshold, $\sigma$ is the noise standard deviation, and $d$ is the signal-to-noise ratio.

## Python Implementation

In this section, we will provide Python implementation for the SC detector and its variants.

```python
import numpy as np
import scipy.special as sp

def sc_detector(x, fs, fc, bw, th):
    # Generate sawtooth waveform
    N = len(x)
    t = np.linspace(0, N/fs, N, endpoint=False)
    sawtooth = sp.sawtooth(2 * np.pi * fc * t)
    # Multiply input signal with sawtooth waveform
    s_out = x * sawtooth
    # Apply bandpass filter
    b, a = signal.butter(4, [fc-bw/2, fc+bw/2], btype='band')
    s_out = signal.filtfilt(b, a, s_out)
    # Rectify and low-pass filter
    s_out = np.abs(s_out)
    b, a = signal.butter(4, 2 * fc / fs, btype='low')
    s_out = signal.filtfilt(b, a, s_out)
    # Thresholding
    if np.max(s_out) > th:
        return True
    else:
        return False

def qsc_detector(x, fs, fc, bw, th):
    # Generate I and Q reference signals
    N = len(x)
    t = np.linspace(0, N/fs, N, endpoint=False)
    i_ref = np.cos(2 * np.pi * fc * t)
    q_ref = np.sin(2 * np.pi * fc * t)
    # Multiply input signal with I and Q reference signals
    i_out = x * i_ref
    q_out = x * q_ref
    # Apply bandpass filter
    b, a = signal.butter(4, [fc-bw/2, fc+bw/2], btype='band')
    i_out = signal.filtfilt(b, a, i_out)
    q_out = signal.filtfilt(b, a, q_out)
    # Rectify and low-pass filter
    i_out = np.abs(i_out)
    q_out = np.abs(q_out)
    b, a = signal.butter(4, 2 * fc / fs, btype='low')
    i_out = signal.filtfilt(b, a, i_out)
    q_out = signal.filtfilt(b, a, q_out)
    # Sum the envelope outputs of I and Q channels
    s_out = i_out + q_out
    # Thresholding
    if np.max(s_out) > th:
        return True
    else:
        return False

def mss_detector(x, fs, fc, bw, th, N):
    # Generate sawtooth waveform for each stage
    t = np.linspace(0, len(x)/fs, len(x), endpoint=False)
    stages = []
    for i in range(N):
        stage = sp.sawtooth(2 * np.pi * fc[i] * t)
        stages.append(stage)
    # Apply bandpass filter for each stage
    s_out = np.zeros(len(x))
    for i in range(N):
        b, a = signal.butter(4, [fc[i]-bw[i]/2, fc[i]+bw[i]/2], btype='band')
        s_out_stage = signal.filtfilt(b, a, x * stages[i])
        # Rectify and low-pass filter
        s_out_stage = np.abs(s_out_stage)
        b, a = signal.butter(4, 2 * fc[i] / fs, btype='low')
        s_out_stage = signal.filtfilt(b, a, s_out_stage)
        # Add the envelope output of the current stage to the final output
        s_out += s_out_stage
    # Thresholding
    if np.max(s_out) > th:
        return True
    else:
        return False

def mbs_detector(x, fs, fc, bw, th, N):
    # Apply bandpass filter for each band
    s_out = np.zeros(len(x))
    for i in range(N):
        b, a = signal.butter(4, [fc[i]-bw[i]/2, fc[i]+bw[i]/2], btype='band')
        s_out_band = signal.filtfilt(b, a, x)
        # Rectify and low-pass filter
        s_out_band = np.abs(s_out_band)
        b, a = signal.butter(4, 2 * fc[i] / fs, btype='low')
        s_out_band = signal.filtfilt(b, a, s_out_band)
        # Add the envelope output of the current band to the final output
        s_out += s_out_band
    # Thresholding
    if np.max(s_out) > th:
        return True
    else:
        return False
```

## Conclusion

In summary, non-linear detectors like the Sequentially Cyclic (SC) detector and its variants (Quadrature SC Detector, Multi-Stage SC Detector, Multi-Band SC Detector) are widely used in communication systems for detecting the presence of a signal in noise. The SC detector works by multiplying the input signal with a sawtooth waveform and filtering the output signal to obtain the envelope. The envelope is compared to a threshold to determine the presence of a signal. 

We have detailed the statistics and equations for the SC detector and its variants, along with Python implementation for each variant. These detectors have practical applications in various areas of signal processing, such as communications, radar, and medical imaging.